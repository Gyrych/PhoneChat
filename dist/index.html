<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FreeChat</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="prompts.js"></script>
    <script>
        // 按需加载 Markdown 渲染与消毒库（非阻塞，用于减少首屏加载体积）
        window._markdownLibsLoaded = false;
        function ensureMarkdownLibs() {
            if (window._markdownLibsLoaded) return Promise.resolve();
            return new Promise((resolve, reject) => {
                try {
                    const m = document.createElement('script');
                    m.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
                    m.async = true;
                    m.onload = () => {
                        const d = document.createElement('script');
                        d.src = 'https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js';
                        d.async = true;
                        d.onload = () => { window._markdownLibsLoaded = true; resolve(); };
                        d.onerror = reject;
                        document.head.appendChild(d);
                    };
                    m.onerror = reject;
                    document.head.appendChild(m);
                } catch (e) { reject(e); }
            });
        }

        // 按需加载 tiktoken 库用于准确的 token 计数（非阻塞）
        window._tiktokenLoaded = false;
        window._tiktokenEncoder = null;
        function ensureTiktoken() {
            if (window._tiktokenLoaded) return Promise.resolve();
            return new Promise((resolve) => {
                try {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/js-tiktoken@1.0.7/dist/tiktoken.js';
                    script.async = true;
                    script.onload = () => {
                        try {
                            // 初始化编码器（使用cl100k_base，适用于GPT-3.5/4等模型）
                            if (window.tiktoken) {
                                window._tiktokenEncoder = window.tiktoken.encodingForModel('gpt-3.5-turbo');
                                window._tiktokenLoaded = true;
                            }
                        } catch (e) {
                            console.warn('Tiktoken 初始化失败，将使用估算方法：', e);
                        }
                        resolve();
                    };
                    script.onerror = () => {
                        console.warn('Tiktoken 加载失败，将使用估算方法');
                        resolve(); // 即使失败也resolve，允许降级
                    };
                    document.head.appendChild(script);
                } catch (e) {
                    console.warn('Tiktoken 加载异常：', e);
                    resolve();
                }
            });
        }

        // 页面加载时预加载tiktoken（非阻塞）
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => ensureTiktoken(), 500);
            });
        } else {
            setTimeout(() => ensureTiktoken(), 500);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="logger.js"></script>
    <script src="script.js"></script>
</head>
<body>



    <div class="app-shell chat-app">
        <header class="app-bar">
            <div class="app-brand">
                <button id="conversationsBtn" class="app-menu-btn" aria-label="打开会话抽屉" title="会话列表">
                    <i class="fas fa-bars"></i>
                </button>
                <img src="icon/logo.png" alt="FreeChat" class="welcome-logo" style="height:40px;width:40px;border-radius:10px;" />
                <div class="brand-text">
                    <h1>FreeChat</h1>
                    <span class="app-pill">数据仅保存在此设备</span>
                </div>
            </div>
            <div class="app-context">
                <strong>自由对话 · 私密守护</strong>
                <span>无需登录 · 支持手机与电脑浏览器</span>
            </div>
            <div class="app-actions">
                <a href="config.html" class="settings-btn" title="设置" aria-label="打开设置页面">
                    <i class="fas fa-cog"></i>
                </a>
            </div>
        </header>
        <main>
            <div class="chat-layout">
                <!-- 会话抽屉（桌面常驻，移动保持抽屉行为） -->
                <aside id="drawer" class="drawer chat-drawer" aria-hidden="true" aria-label="会话抽屉">
                    <div class="drawer-header">
                        <button id="drawerNewChatBtn" class="drawer-primary">新建会话</button>
                        <input id="drawerSearch" class="drawer-search" placeholder="搜索会话或分组" />
                    </div>

                    <!-- 收藏夹区域 -->
                    <div class="drawer-section favorites-section">
                        <div class="drawer-section-header" id="favoritesHeader">
                            <i class="fas fa-star" style="color: #f59e0b;"></i>
                            <span style="flex: 1; font-weight: 600;">收藏夹</span>
                            <i class="fas fa-chevron-down" id="favoritesToggleIcon"></i>
                        </div>
                        <div id="favoritesContainer" class="drawer-section-content"></div>
                    </div>

                    <!-- 会话列表区域 -->
                    <div class="drawer-section">
                        <div class="drawer-section-header">
                            <i class="fas fa-comments"></i>
                            <span style="flex: 1; font-weight: 600;">会话列表</span>
                        </div>
                        <nav id="drawerList" class="drawer-list"></nav>
                    </div>

                    <div class="drawer-footer">
                        <a href="conversations.html" class="drawer-icon-btn" aria-label="会话管理" title="会话管理">
                            <i class="fas fa-list"></i>
                        </a>
                    </div>
                </aside>
                <!-- 聊天主体 -->
                <section class="chat-body">
                    <div id="sessionTitleBar" class="chat-header glass" aria-hidden="false">
                        <div class="session-meta">
                            <div class="session-name-row">
                                <div class="session-name" id="sessionName">未命名会话</div>
                                <div id="memoryStatusBadge" class="memory-badge" title="记忆状态"></div>
                            </div>
                            <div class="session-group" id="sessionGroup">未分组</div>
                        </div>
                        <div class="session-actions">
                            <div id="currentModelBadge" class="session-model model-badge" title="当前模型">未选择模型</div>
                        </div>
                    </div>
                    <section id="welcomeHero" class="welcome-hero">
                        <div class="welcome-brand-line">
                            <img src="icon/logo.png" alt="FreeChat" class="welcome-logo" />
                            <h2 class="welcome-title">FreeChat</h2>
                        </div>
                        <p class="welcome-subtitle">端侧私密 · 离线可用 · 多设备统一体验</p>
                    </section>
                    <div id="messageContainer" class="message-container"></div>
                    <div id="statusIndicator" class="status-indicator" aria-live="polite"></div>
                    <footer class="input-container typewriter-style">
                        <div class="input-main">
                            <!-- Token 使用进度条：对话输入框顶部的极窄进度条 -->
                            <div class="token-strip">
                                <div class="token-meter" aria-label="Token 使用进度">
                                    <span id="tokenMeterFill" style="width:0%;"></span>
                                </div>
                                <span id="tokenCountLabel" class="token-count-label">0 / 1024 tokens</span>
                            </div>
                            <textarea
                                id="messageInput"
                                class="message-input"
                                placeholder="输入内容（Enter 发送，Shift+Enter 换行）"
                                rows="3"
                            ></textarea>
                        </div>
                        <div class="composer-primary input-bottom">
                            <div class="input-tools input-tools-main" aria-label="输入工具栏">
                            <button id="thinkingInlineToggle" class="pill-toggle thinking-inline-toggle" title="深度思考" aria-label="切换深度思考">
                                <i class="fas fa-brain"></i>
                            </button>
                            <button id="webInlineToggle" class="pill-toggle web-inline-toggle" title="联网搜索" aria-label="切换联网搜索">
                                <i class="fas fa-globe"></i>
                            </button>
                            <button id="voiceBtn" class="pill-toggle" title="语音输入（实验中）" aria-label="语音输入（实验中）">
                                <i class="fas fa-microphone"></i>
                            </button>
                            <button id="attachBtn" class="pill-toggle" title="添加附件" aria-label="添加附件">
                                <i class="fas fa-paperclip"></i>
                            </button>
                            <input id="fileInput" type="file" multiple style="display:none" />
                            </div>
                            <div class="input-tools input-tools-actions">
                                <button id="sendBtn" class="sendBtn send-btn circle-btn" title="发送" aria-label="发送消息">
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                                <button id="stopBtn" class="stop-btn circle-btn" title="停止生成" aria-label="停止生成">
                                    <i class="fas fa-stop"></i>
                                </button>
                            </div>
                        </div>
                    </footer>
                </section>
            </div>
        </main>
    </div>

    <!-- 覆盖式会话抽屉与遮罩（移动端） -->
    <div id="drawerOverlay" class="drawer-overlay" aria-hidden="true"></div>

    <!-- 全局提示 -->
    <div id="toastStack" class="toast-stack" aria-live="polite" aria-atomic="true"></div>
    <div id="statusBar" class="status-bar" role="status">
        <i class="fas fa-circle-notch fa-spin"></i>
        <span id="statusBarText">准备就绪</span>
    </div>

    <script>
        /**
         * 文件名：index.html
         * 功能描述：FreeChat 主聊天页面，提供聊天界面、消息发送与接收、流式响应显示、会话管理等功能
         */
        // 覆盖式会话抽屉开关（点击按钮/遮罩/ESC）
        (function initDrawerToggle() {
            const btn = document.getElementById('conversationsBtn');
            const overlay = document.getElementById('drawerOverlay');
            if (btn) btn.addEventListener('click', () => toggleDrawer());
            if (overlay) overlay.addEventListener('click', () => closeDrawer());
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeDrawer(); });
        })();

        let currentConversation = [];
        let currentConversationGroupId = null;
        window.DEEPSEEK_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
        const MODEL_NAME = localStorage.getItem('chatModel') || 'minimax/minimax-m2:free';
        window.MODEL_NAME = MODEL_NAME;

        // 运行时读取当前模型的辅助方法（避免在脚本初始化时缓存导致不同步）
        function getCurrentModel() {
            try {
                return localStorage.getItem('chatModel') || (window.MODEL_NAME || 'minimax/minimax-m2:free');
            } catch (_) {
                return (window.MODEL_NAME || 'minimax/minimax-m2:free');
            }

            if (voiceBtn) {
                voiceBtn.addEventListener('click', () => {
                    showToast('语音输入功能正在打磨，暂时请使用键盘输入。');
                });
            }

            try { syncDrawerMode(); } catch (_) {}
            try {
                const mq = window.matchMedia && window.matchMedia('(min-width: 960px)');
                if (mq) {
                    const handler = () => { try { syncDrawerMode(); } catch (_) {} };
                    if (mq.addEventListener) mq.addEventListener('change', handler);
                    else if (mq.addListener) mq.addListener(handler);
                }
            } catch (_) {}
        }
        /**
         * 获取全局模型参数（从 localStorage.freechat.modelParams）
         * 返回默认值对象（保证字段存在）
         */
        function getGlobalModelParams() {
            try {
                const raw = localStorage.getItem('freechat.modelParams');
                if (!raw) return { temperature: 0.7, top_p: 0.9, max_tokens: 1024, stream: true };
                const parsed = JSON.parse(raw || 'null') || {};
                return {
                    temperature: typeof parsed.temperature !== 'undefined' ? parsed.temperature : 0.7,
                    top_p: typeof parsed.top_p !== 'undefined' ? parsed.top_p : 0.9,
                    max_tokens: typeof parsed.max_tokens !== 'undefined' ? parsed.max_tokens : 1024,
                    stream: typeof parsed.stream !== 'undefined' ? !!parsed.stream : true
                };
            } catch (e) {
                console.error('读取全局模型参数失败：', e);
                return { temperature: 0.7, top_p: 0.9, max_tokens: 1024, stream: true };
            }
        }

        function getConversationModelParams(conv) {
            try {
                if (!conv) return null;
                if (conv.modelParams && typeof conv.modelParams === 'object') return conv.modelParams;
                return null;
            } catch (_) { return null; }
        }

        function getEffectiveModelParams(conv) {
            const globalParams = getGlobalModelParams() || {};
            const convParams = getConversationModelParams(conv) || {};
            return Object.assign({}, globalParams, convParams);
        }

        function getEffectiveSystemPrompt(conv) {
            try {
                if (conv && conv.systemPrompt && String(conv.systemPrompt).trim()) return String(conv.systemPrompt).trim();
                const g = localStorage.getItem('freechat.systemPrompt');
                return g ? String(g).trim() : '';
            } catch (e) { return ''; }
        }

        const LOCAL_PASSPHRASE = 'local_obfuscation_passphrase_2025';
        const ENCRYPTED_OPENROUTER_KEY = 'U2FsdGVkX18PSVwBhdx/XQSmTwr5UimvbPYKhcmoMNXytQwT4HgYIMh2Hl/BxCv/0zYPUjEzfprco76j74BEMQIjYwM5iIkP7VMSS1vKYLqbhNjbCqP369SdZlcmikUg';

        /**
         * 解密API密钥
         * 参数：encryptedBase64 - 加密后的Base64字符串，passphrase - 解密密码
         * 返回值：解密后的API密钥字符串，失败返回null
         */
        function decryptApiKey(encryptedBase64, passphrase) {
            try {
                const bytes = CryptoJS.AES.decrypt(encryptedBase64, passphrase);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                console.error('解密 API Key 失败：', e);
                return null;
            }
        }

        const OPENROUTER_API_KEY = decryptApiKey(ENCRYPTED_OPENROUTER_KEY, LOCAL_PASSPHRASE);
        window.OPENROUTER_API_KEY = OPENROUTER_API_KEY;
        const messageContainer = document.getElementById('messageContainer');
        /**
         * 批量/合并 localStorage 写入（按 key 合并，延迟执行以减少同步 I/O）
         * 用法：batchedStorageSetJson('deepseekConversation', obj)
         */
        const _batchedStorageQueue = Object.create(null);
        function batchedStorageSetJson(key, value, delay = 400) {
            try {
                if (!_batchedStorageQueue[key]) {
                    _batchedStorageQueue[key] = { timer: null, val: null };
                }
                _batchedStorageQueue[key].val = value;
                if (_batchedStorageQueue[key].timer) return;
                _batchedStorageQueue[key].timer = setTimeout(() => {
                    try {
                        const v = _batchedStorageQueue[key].val;
                        localStorage.setItem(key, JSON.stringify(v));
                    } catch (e) { console.error('batchedStorageSetJson 写入失败：', e); }
                    clearTimeout(_batchedStorageQueue[key].timer);
                    _batchedStorageQueue[key].timer = null;
                }, delay);
            } catch (e) { console.error('batchedStorageSetJson 调度失败：', e); }
        }

        /**
         * 懒加载 Markdown / DOMPurify 库（首次使用时动态注入脚本）
         * 返回 Promise，在库加载完成后 resolve
         */
        let _markdownLibsPromise = null;
        function ensureMarkdownLibs() {
            if (typeof window.marked !== 'undefined' && typeof window.DOMPurify !== 'undefined') {
                return Promise.resolve();
            }
            if (_markdownLibsPromise) return _markdownLibsPromise;
            _markdownLibsPromise = new Promise((resolve, reject) => {
                try {
                    const loadScript = (src) => new Promise((res, rej) => {
                        const s = document.createElement('script');
                        s.src = src;
                        s.onload = () => res();
                        s.onerror = (e) => rej(e);
                        document.head.appendChild(s);
                    });
                    // 依次加载 marked 与 DOMPurify（保证两者均可用）
                    loadScript('https://cdn.jsdelivr.net/npm/marked/marked.min.js')
                        .then(() => loadScript('https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js'))
                        .then(() => resolve())
                        .catch((err) => {
                            console.error('加载 Markdown 库失败：', err);
                            resolve(); // 回退为文本渲染，避免阻塞主流程
                        });
                } catch (e) {
                    console.error('ensureMarkdownLibs 异常：', e);
                    resolve();
                }
            });
            return _markdownLibsPromise;
        }

        /** 自动调整输入框高度，确保长文本不遮挡操作区 */
        function autoResizeTextarea(el) {
            if (!el) return;
            el.style.height = 'auto';
            const max = 220;
            const next = Math.min(max, el.scrollHeight);
            el.style.height = next + 'px';
        }

        /** 根据字符长度估算 token 使用情况（支持tiktoken精确计数和改进的估算降级方案） */
        function updateTokenMeter() {
            if (!tokenMeterFill || !tokenCountLabel) return;
            try {
                const text = messageInput ? String(messageInput.value || '') : '';
                let approxTokens = 0;

                // 方案1：使用tiktoken进行精确计数（如果已加载）
                if (window._tiktokenLoaded && window._tiktokenEncoder) {
                    try {
                        const tokens = window._tiktokenEncoder.encode(text);
                        approxTokens = tokens.length;
                    } catch (e) {
                        console.warn('Tiktoken计数失败，使用估算方法：', e);
                        approxTokens = estimateTokens(text);
                    }
                } else {
                    // 方案2：改进的估算算法（中文1字≈2token，英文4字符≈1token）
                    approxTokens = estimateTokens(text);
                }

                const maxTokens = Math.max(1, Number(getGlobalModelParams().max_tokens || 1024));
                const percent = Math.min(100, (approxTokens / maxTokens) * 100);
                tokenMeterFill.style.width = percent + '%';
                tokenMeterFill.classList.toggle('critical', percent > 90);
                tokenCountLabel.textContent = `${approxTokens} / ${maxTokens} tokens`;
            } catch (e) {
                tokenCountLabel.textContent = 'Token 统计不可用';
            }
        }

        /** 改进的token估算算法（降级方案） */
        function estimateTokens(text) {
            if (!text) return 0;
            let tokenCount = 0;
            // 分离中文字符和非中文字符
            const chineseChars = text.match(/[\u4e00-\u9fa5]/g) || [];
            const nonChineseText = text.replace(/[\u4e00-\u9fa5]/g, '');

            // 中文：1个字符约等于2个token
            tokenCount += chineseChars.length * 2;

            // 英文及其他：约4个字符等于1个token
            tokenCount += Math.ceil(nonChineseText.length / 4);

            return Math.max(0, tokenCount);
        }

        /** 桌面宽度判定，用于同步抽屉模式 */
        function isDesktopLayout() {
            try { return window.matchMedia && window.matchMedia('(min-width: 960px)').matches; } catch (_) { return false; }
        }

        /** 统一轻量通知 */
        function showToast(message, type = 'info', duration = 3200) {
            if (!toastStack) return;
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            const icon = document.createElement('i');
            icon.className = type === 'error' ? 'fas fa-exclamation-circle' : (type === 'success' ? 'fas fa-check-circle' : 'fas fa-info-circle');
            const text = document.createElement('span');
            text.textContent = message;
            toast.appendChild(icon);
            toast.appendChild(text);
            toastStack.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('leaving');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const stopBtn = document.getElementById('stopBtn');
        const webInlineToggle = document.getElementById('webInlineToggle');
        const thinkingInlineToggle = document.getElementById('thinkingInlineToggle');
        const attachBtn = document.getElementById('attachBtn');
        const voiceBtn = document.getElementById('voiceBtn');
        const fileInput = document.getElementById('fileInput');
        const statusIndicator = document.getElementById('statusIndicator');
        const tokenMeterFill = document.getElementById('tokenMeterFill');
        const tokenCountLabel = document.getElementById('tokenCountLabel');
        const toastStack = document.getElementById('toastStack');
        const statusBarEl = document.getElementById('statusBar');
        const statusBarText = document.getElementById('statusBarText');
        // 当前请求控制器与发送锁，用于支持真正中止和防止并发发送
        window._currentRequestController = null;
        window._sendingInProgress = false;
        // 抽屉相关元素
        const drawerEl = document.getElementById('drawer');
        const drawerOverlayEl = document.getElementById('drawerOverlay');
        const drawerListEl = document.getElementById('drawerList');
        const drawerSearchEl = document.getElementById('drawerSearch');
        const drawerNewChatBtn = document.getElementById('drawerNewChatBtn');
        const welcomeHero = document.getElementById('welcomeHero');

        // 本地存储兼容迁移：将历史字段回填到现用字段（一次性、失败忽略）
        (function migrateStorageCompat(){
            try {
                let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations')||'[]');
                let changed = false;
                for (const c of saved) {
                    if (c && c.memory && !c.summary) { c.summary = c.memory; changed = true; }
                }
                if (changed) localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));

                let groups = JSON.parse(localStorage.getItem('conversationGroups')||'[]');
                let gChanged = false;
                for (const g of groups) {
                    if (g && g.groupMemory && !g.memorySummary) { g.memorySummary = g.groupMemory; gChanged = true; }
                }
                if (gChanged) localStorage.setItem('conversationGroups', JSON.stringify(groups));
            } catch(_) { /* 迁移失败不影响主流程 */ }
        })();

        /**
         * 初始化应用
         * 功能：加载会话数据、渲染消息、绑定事件监听器（发送按钮、输入框、停止按钮等）
         * 参数：无
         * 返回值：无
         */
        function initApp() {
            if (window._appInitialized) return;
            window._appInitialized = true;

            console.log('initApp: attaching handlers');
            // 后台预加载 Markdown 库以降低首次渲染延迟（非阻塞）
            try {
                // 非阻塞加载；为保证历史消息能正确渲染 Markdown，加载完成后再尝试重渲染一次历史消息
                // 注意：这里也要传递 true 跳过打字机动画，因为是重新渲染历史消息
                ensureMarkdownLibs()
                    .then(() => { try { renderMessages(true); } catch(_) {} })
                    .catch(() => {});
            } catch (_) {}
            try { updateCurrentModelBadge(); } catch (e) { /* 忽略徽标更新异常 */ }
            // 在跨窗口/标签页更新 localStorage.chatModel 时刷新徽标（便于从配置页修改后自动反映）
            try {
                window.addEventListener('storage', (e) => {
                    try {
                        if (e.key === 'chatModel') updateCurrentModelBadge();
                    } catch (_) {}
                });
            } catch (_) {}

            // 初始化收藏夹
            try {
                updateFavoritesDrawer();
                // 收藏夹折叠/展开功能
                const favoritesHeader = document.getElementById('favoritesHeader');
                const favoritesContainer = document.getElementById('favoritesContainer');
                const favoritesToggleIcon = document.getElementById('favoritesToggleIcon');
                if (favoritesHeader && favoritesContainer) {
                    favoritesHeader.addEventListener('click', () => {
                        favoritesContainer.classList.toggle('collapsed');
                        if (favoritesToggleIcon) {
                            favoritesToggleIcon.className = favoritesContainer.classList.contains('collapsed')
                                ? 'fas fa-chevron-right'
                                : 'fas fa-chevron-down';
                        }
                    });
                }
            } catch (e) {
                console.error('初始化收藏夹失败：', e);
            }
            // 绑定品牌 Logo 点击：回到首页
            const brandLogo = document.getElementById('brandLogo');
            if (brandLogo) {
                brandLogo.addEventListener('click', function() {
                    window.location.assign('index.html');
                });
            }
            loadConversation();
            renderMessages(true); // 加载历史会话时禁用打字机动画
            renderWelcomeIfEmpty();
            try {
                autoResizeTextarea(messageInput);
                updateTokenMeter();
            } catch (_) {}

            // 初始化抽屉列表、搜索与“新建会话”
            try {
                renderDrawerConversationsList();
                if (drawerSearchEl) {
                    drawerSearchEl.addEventListener('input', () => {
                        const q = (drawerSearchEl.value || '').trim();
                        renderDrawerConversationsList(q);
                    });
                }
                if (drawerNewChatBtn) {
                    drawerNewChatBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        openNewChatGroupModal();
                    });
                }
            } catch (_) { /* 忽略抽屉初始化异常 */ }
            // 联网搜索参数已迁移至设置页，无需在主页面初始化面板
            if (sendBtn) {
                sendBtn.addEventListener('click', sendMessage);
                sendBtn.onclick = sendMessage;
            } else {
                console.error('sendBtn 未找到');
            }

            if (messageInput) {
                messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        sendMessage();
                        return;
                    }
                    if (e.key === 'Enter' && !e.shiftKey && !e.altKey && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
                messageInput.addEventListener('input', () => {
                    autoResizeTextarea(messageInput);
                    updateTokenMeter();
                });
            }

            // 初始化内联“联网搜索”开关
            try {
                const applyToggleUi = (on) => {
                    if (!webInlineToggle) return;
                    if (on) webInlineToggle.classList.add('active');
                    else webInlineToggle.classList.remove('active');
                    webInlineToggle.setAttribute('aria-pressed', on ? 'true' : 'false');
                };
                const enabled = (localStorage.getItem('freechat.web.enable') || 'false') === 'true';
                applyToggleUi(enabled);
                if (webInlineToggle) {
                    webInlineToggle.addEventListener('click', (e) => {
                        e.preventDefault();
                        const curr = (localStorage.getItem('freechat.web.enable') || 'false') === 'true';
                        const next = !curr;
                        if (next) localStorage.setItem('freechat.web.enable', 'true');
                        else localStorage.setItem('freechat.web.enable', 'false');
                        applyToggleUi(next);
                        try { showStatus(next ? '已启用联网搜索' : '已关闭联网搜索'); setTimeout(hideStatus, 1800); } catch (_) {}
                    });
                }
            } catch (_) { /* 忽略内联开关初始化异常 */ }

            // 初始化“深度思考”开关（仅控制是否显示推理内容，不改变请求参数）
            try {
                const applyThinkingUi = (on) => {
                    if (!thinkingInlineToggle) return;
                    if (on) thinkingInlineToggle.classList.add('active');
                    else thinkingInlineToggle.classList.remove('active');
                    thinkingInlineToggle.setAttribute('aria-pressed', on ? 'true' : 'false');
                };
                const rEnabled = (localStorage.getItem('freechat.reasoning.show') || 'true') === 'true';
                applyThinkingUi(rEnabled);
                thinkingInlineToggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    const curr = (localStorage.getItem('freechat.reasoning.show') || 'true') === 'true';
                    const next = !curr;
                    localStorage.setItem('freechat.reasoning.show', next ? 'true' : 'false');
                    applyThinkingUi(next);
                    try { showStatus(next ? '将显示思考过程' : '将隐藏思考过程'); setTimeout(hideStatus, 1600); } catch (_) {}
                });
            } catch (_) { /* 忽略异常 */ }

            // 附件按钮与文件选择（仅记录名称，后续按需接入解析）
            try {
                if (attachBtn && fileInput) {
                    attachBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        fileInput.click();
                    });
                    fileInput.addEventListener('change', () => {
                        const files = Array.from(fileInput.files || []);
                        window._attachedFiles = files; // 临时保存所选文件
                        if (files.length) {
                            const names = files.slice(0, 3).map(f => f.name).join('、');
                            const more = files.length > 3 ? ` 等 ${files.length} 个文件` : '';
                            showStatus(`已选择：${names}${more}`);
                        } else {
                            showStatus('未选择文件');
                        }
                        setTimeout(hideStatus, 2000);
                    });
                }
            } catch (_) { /* 忽略附件初始化异常 */ }

            stopBtn.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                stopGeneration();
            });

            stopBtn.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: true });

            // 日志导出 UI 已从页眉移除；如需导出，请在控制台调用 Logger.export(...)
        }

        document.addEventListener('DOMContentLoaded', initApp);
        window.addEventListener('load', initApp);

        /** 打开/关闭抽屉（桌面常驻、移动抽屉） */
        function syncDrawerMode() {
            if (!drawerEl) return;
            if (isDesktopLayout()) {
                drawerEl.classList.add('open');
                drawerEl.setAttribute('aria-hidden', 'false');
                if (drawerOverlayEl) {
                    drawerOverlayEl.classList.remove('open');
                    drawerOverlayEl.setAttribute('aria-hidden', 'true');
                }
                try { document.body.classList.remove('drawer-open'); } catch (_) {}
            } else {
                if (drawerEl.classList.contains('open')) return;
                drawerEl.setAttribute('aria-hidden', 'true');
                if (drawerOverlayEl) {
                    drawerOverlayEl.classList.remove('open');
                    drawerOverlayEl.setAttribute('aria-hidden', 'true');
                }
                try { document.body.classList.remove('drawer-open'); } catch (_) {}
            }
        }
        function openDrawer() {
            if (isDesktopLayout()) {
                syncDrawerMode();
                if (drawerSearchEl && typeof drawerSearchEl.focus === 'function') {
                    setTimeout(() => { try { drawerSearchEl.focus(); } catch (_) {} }, 0);
                }
                return;
            }
            try {
                if (drawerEl) drawerEl.classList.add('open');
                if (drawerEl) drawerEl.setAttribute('aria-hidden', 'false');
                if (drawerOverlayEl) drawerOverlayEl.classList.add('open');
                if (drawerOverlayEl) drawerOverlayEl.setAttribute('aria-hidden', 'false');
                try { document.body.classList.add('drawer-open'); } catch (_) {}
            } catch (_) {}
            try { adjustSessionTitleHeight(); } catch (_) {}
        }
        function closeDrawer() {
            if (isDesktopLayout()) return;
            try {
                if (drawerEl) drawerEl.classList.remove('open');
                if (drawerEl) drawerEl.setAttribute('aria-hidden', 'true');
                if (drawerOverlayEl) drawerOverlayEl.classList.remove('open');
                if (drawerOverlayEl) drawerOverlayEl.setAttribute('aria-hidden', 'true');
                try { document.body.classList.remove('drawer-open'); } catch (_) {}
            } catch (_) {}
        }
        function toggleDrawer() {
            if (!drawerEl) return;
            if (isDesktopLayout()) {
                if (drawerSearchEl && typeof drawerSearchEl.focus === 'function') {
                    drawerSearchEl.focus();
                }
                return;
            }
            if (drawerEl.classList.contains('open')) closeDrawer(); else openDrawer();
        }

        /** 渲染抽屉会话列表（基础：加载/删除） */
        function renderDrawerConversationsList(filterText = '') {
            if (!drawerListEl) return;
            const q = (filterText || '').toLowerCase();
            drawerListEl.innerHTML = '';
            const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
            const groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');

            function fmtTime(ts) {
                try { const d = new Date(ts || Date.now()); return `${d.getMonth() + 1}月${d.getDate()}日 ${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}`; } catch (_) { return ''; }
            }
            function renderGroupSection(groupObj, list) {
                const esc = (s) => String(s || '').replace(/[&<>"']/g, (ch) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
                const title = groupObj ? (groupObj.name || '分组') : '未分组';
                const details = document.createElement('details');
                details.className = 'drawer-section';
                const summary = document.createElement('summary');
                summary.innerHTML = `<span class="summary-line"><i class="fas fa-folder"></i><span>${esc(title)}</span></span>`;
                const items = document.createElement('div');
                items.className = 'drawer-items';

                // 分组记忆与操作（仅对真实分组显示）
                if (groupObj && groupObj.id) {
                    // 记忆块
                    const memoryDiv = document.createElement('div');
                    memoryDiv.className = 'group-memory';
                    memoryDiv.style.display = 'none';
                    memoryDiv.innerHTML = groupObj.memorySummary ? `<strong>分组记忆：</strong><div>${esc(groupObj.memorySummary)}</div>` : '<i class="small-muted">暂无分组记忆</i>';
                    // 查看按钮
                    const viewMemoryBtn = document.createElement('button');
                    viewMemoryBtn.className = 'view-memory-btn';
                    viewMemoryBtn.textContent = groupObj.memorySummary ? '查看分组记忆' : '暂无分组记忆';
                    viewMemoryBtn.style.margin = '8px 12px';
                    viewMemoryBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const show = memoryDiv.style.display === 'none';
                        memoryDiv.style.display = show ? 'block' : 'none';
                        viewMemoryBtn.textContent = show ? '隐藏分组记忆' : (groupObj.memorySummary ? '查看分组记忆' : '暂无分组记忆');
                    });
                    // 重命名按钮
                    const renameBtn = document.createElement('button');
                    renameBtn.className = 'group-rename-btn';
                    renameBtn.title = '重命名分组';
                    renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    renameBtn.style.marginLeft = '8px';
                    renameBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const newName = prompt('输入新的分组名称：', groupObj.name || '');
                        if (!newName) return;
                        try {
                            let gs = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                            const gi = gs.findIndex(g => g.id === groupObj.id);
                            if (gi !== -1) {
                                gs[gi].name = newName;
                                gs[gi].updatedAt = new Date().toISOString();
                                localStorage.setItem('conversationGroups', JSON.stringify(gs));
                                renderDrawerConversationsList(q);
                            }
                        } catch (err) { console.error('重命名分组失败：', err); }
                    });
                    // 重新记忆按钮
                    const regenBtn = document.createElement('button');
                    regenBtn.className = 'group-regen-btn';
                    regenBtn.title = '重新生成分组记忆';
                    regenBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    regenBtn.style.marginLeft = '6px';
                    regenBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (!confirm('确定要为该分组重新生成分组记忆吗？可能产生API调用费用。')) return;
                        try { await updateGroupMemory(groupObj.id); renderDrawerConversationsList(q); alert('分组记忆已更新'); }
                        catch (err) { console.error('重新生成分组记忆失败：', err); alert('更新失败'); }
                    });
                    // 将重新生成分组记忆按钮挂到 summary 上（保留重新生成按钮，移除重命名入口）
                    summary.appendChild(regenBtn);
                    items.appendChild(viewMemoryBtn);
                    items.appendChild(memoryDiv);
                }
                for (const c of list) {
                    const item = document.createElement('div');
                    item.className = 'drawer-item';
                    const left = document.createElement('div');
                    const name = document.createElement('div');
                    name.className = 'name';
                    name.textContent = c.name || '未命名会话';
                    const time = document.createElement('div');
                    time.className = 'time';
                    time.textContent = fmtTime(c.updatedAt || c.timestamp);
                    // 会话名（单行） — 模型将作为独立一行放在最后
                    const nameRow = document.createElement('div');
                    nameRow.appendChild(name);
                    left.appendChild(nameRow);
                    left.appendChild(time);
                    // 单独新行显示模型名称（若存在）
                    const modelRow = document.createElement('div');
                    modelRow.className = 'conversation-model';
                    modelRow.textContent = (c.model || '').toString();
                    if (!modelRow.textContent) modelRow.style.display = 'none';
                    left.appendChild(modelRow);
                    // 会话记忆折叠区（显示 saved.summary）
                    const summaryToggle = document.createElement('button');
                    summaryToggle.className = 'toggle-summary-btn';
                    summaryToggle.textContent = '查看会话记忆';
                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'conversation-summary-content';
                    summaryDiv.style.display = 'none';
                    summaryDiv.style.marginTop = '6px';
                    summaryDiv.innerHTML = c.summary ? esc(c.summary) : '<i class="small-muted">记忆生成中或不存在</i>';
                    summaryToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const on = (summaryDiv.style.display === 'none');
                        summaryDiv.style.display = on ? 'block' : 'none';
                        summaryToggle.textContent = on ? '隐藏会话记忆' : '查看会话记忆';
                    });
                    left.appendChild(summaryToggle);
                    left.appendChild(summaryDiv);
                    const actions = document.createElement('div');
                    actions.className = 'actions';
                    const loadBtn = document.createElement('button');
                    loadBtn.className = 'action-btn';
                    loadBtn.title = '加载';
                    loadBtn.innerHTML = '<i class="fas fa-download"></i>';
                    loadBtn.addEventListener('click', () => {
                        try {
                            const payload = c.messages || c.content || [];
                            // 在加载持久化会话前，先中止任何正在进行的生成请求，避免流式写回覆盖新加载的数据
                            try {
                                if (window._currentRequestController && typeof window._currentRequestController.abort === 'function') {
                                    try { window._currentRequestController.abort(); } catch(_) {}
                                }
                                // 清理发送锁，确保能正常交互
                                try { window._sendingInProgress = false; } catch(_) {}
                            } catch (_) {}
                            // 取消任何待写入的 batchedStorage 写入，避免旧快照在延迟后覆盖新会话
                            try { if (typeof batchedStorageCancelKey === 'function') batchedStorageCancelKey('deepseekConversation'); } catch(_) {}

                            localStorage.setItem('deepseekConversation', JSON.stringify(payload));
                            if (c.groupId) localStorage.setItem('deepseekConversationGroupId', c.groupId);
                            else localStorage.removeItem('deepseekConversationGroupId');
                            localStorage.setItem('deepseekConversationId', c.id);
                            if (c.model) localStorage.setItem('chatModel', c.model);
                            // 将 deepseekConversation 写入内存并更新 UI
                            loadConversation(); renderMessages(true); renderWelcomeIfEmpty();
                            try { renderSessionTitle(); } catch (_) {}
                            closeDrawer();
                        } catch (e) { console.error('加载会话失败：', e); }
                    });
                    // （简化）仅保留加载与重新生成会话记忆按钮，其他管理操作移到会话管理页
                    // 重新生成会话记忆
                    const regenBtn = document.createElement('button');
                    regenBtn.className = 'action-btn';
                    regenBtn.title = '重新生成会话记忆';
                    regenBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    regenBtn.addEventListener('click', async () => {
                        if (!confirm('确定要为该会话重新生成会话记忆吗？可能产生API调用费用。')) return;
                        try {
                            const arr = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                            const conv = arr.find(x => x.id === c.id);
                            if (!conv) return alert('未找到该会话');
                            const apiKey = window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey');
                            if (!apiKey) return alert('未配置可用的 OpenRouter API Key');
                            if (!window.PROMPTS || !window.PROMPTS.SESSION_SUMMARY) throw new Error('PROMPTS.SESSION_SUMMARY 未找到');
                            const systemPrompt = window.PROMPTS.SESSION_SUMMARY;
                            const userContent = (conv.messages || conv.content || []).map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n');
                            const modelToUse = (conv && conv.model) ? conv.model : (window.MODEL_NAME || 'minimax/minimax-m2:free');
                            const resp = await fetch(window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                                body: JSON.stringify({ model: modelToUse, messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userContent }], temperature: 0.2 })
                            });
                            if (!resp.ok) throw new Error('API请求失败');
                            const data = await resp.json();
                            const summaryText = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content;
                            if (summaryText) {
                                const idx = arr.findIndex(x => x.id === c.id);
                                if (idx !== -1) {
                                    arr[idx].summary = summaryText;
                                    arr[idx].updatedAt = new Date().toISOString();
                                    localStorage.setItem('savedDeepseekConversations', JSON.stringify(arr));
                                    renderDrawerConversationsList(q);
                                }
                            }
                        } catch (err) { console.error('重新生成会话记忆失败：', err); alert('重新生成会话记忆失败，请稍后重试'); }
                    });

                    const delBtn = document.createElement('button');
                    delBtn.className = 'action-btn';
                    delBtn.title = '删除';
                    delBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    delBtn.addEventListener('click', async () => {
                        try {
                            const confirmed = await showConfirmModal('确定要删除这个会话吗？');
                            if (!confirmed) return;
                            let arr = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                            arr = arr.filter(x => x && x.id !== c.id);
                            localStorage.setItem('savedDeepseekConversations', JSON.stringify(arr));
                            renderDrawerConversationsList(q);
                        } catch (e) { console.error('删除会话失败：', e); }
                    });
                    actions.appendChild(loadBtn);
                    actions.appendChild(regenBtn);
                    item.appendChild(left);
                    item.appendChild(actions);
                    items.appendChild(item);
                }
                details.appendChild(summary);
                details.appendChild(items);
                drawerListEl.appendChild(details);
            }
            for (const g of groups) {
                const list = saved
                    .filter(c => c.groupId === g.id)
                    .filter(c => {
                        if (!q) return true;
                        const inGroup = (g.name || '').toLowerCase().includes(q);
                        const inName = (c.name || '').toLowerCase().includes(q);
                        const inModel = (c.model || '').toLowerCase().includes(q);
                        return inGroup || inName || inModel;
                    })
                    .sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));
                if (list.length || (g && g.memorySummary)) renderGroupSection(g, list);
            }
            const ungroup = saved
                .filter(c => !c.groupId)
                .filter(c => {
                    if (!q) return true;
                    const inName = (c.name || '').toLowerCase().includes(q);
                    const inModel = (c.model || '').toLowerCase().includes(q);
                    const inUngroupLabel = '未分组'.includes(q);
                    return inName || inModel || inUngroupLabel;
                })
                .sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));
            if (ungroup.length) renderGroupSection(null, ungroup);
        }

        /**
         * 加载会话
         * 功能：从localStorage加载保存的会话数据和分组ID
         * 参数：无
         * 返回值：无
         */
        function loadConversation() {
            const savedConversation = localStorage.getItem('deepseekConversation');
            if (savedConversation && savedConversation !== 'undefined') {
                try {
                    currentConversation = JSON.parse(savedConversation);
                } catch (err) {
                    console.error('解析 deepseekConversation 失败，已清理该键：', err, savedConversation);
                    currentConversation = [];
                    localStorage.removeItem('deepseekConversation');
                }
            }
            const grp = localStorage.getItem('deepseekConversationGroupId');
            currentConversationGroupId = (grp && grp !== 'undefined' && grp !== 'null') ? grp : null;
            // 加载时尝试同步更新当前模型徽标（若用户从会话管理页恢复了模型）
            try { updateCurrentModelBadge(); } catch (e) { /* 忽略异常 */ }
            try { renderSessionTitle(); } catch (_) {}
        }

        // 主页面保留“联网搜索”内联开关；参数配置改到设置页

        /** 根据是否有消息显示/隐藏欢迎区 */
        function renderWelcomeIfEmpty() {
            try {
                if (!welcomeHero) return;
                const hasMessages = Array.isArray(currentConversation) && currentConversation.length > 0;
                welcomeHero.style.display = hasMessages ? 'none' : 'flex';
            } catch (_) {}
        }

        /**
         * 构建多条 system 提示：分组记忆（逐条）+ 当前分组会话记忆（逐条）
         * 说明：
         * - 注入“所有分组的分组记忆”或仅当前分组，受 localStorage 开关控制：
         *   - freechat.memory.inject.allGroups: 'true'|'false'，默认 'true'（注入全部分组记忆）
         * - 注入“当前分组内所有会话记忆”：
         *   - freechat.memory.inject.groupSessions: 'true'|'false'，默认 'true'
         * - 长度控制：
         *   - freechat.memory.maxConvPerGroup: 数量阈值（默认 10）
         *   - freechat.memory.maxCharsPerSection: 每条 system 最大字符（默认 4000）
         * 返回值：Promise<Array<{role:'system', content:string}>>，空数组表示无需注入
         */
        async function buildMemorySystemPrompts() {
            try {
                const readBool = (key, defVal) => {
                    const v = (localStorage.getItem(key) || '').trim();
                    if (v === '') return defVal;
                    return v === 'true';
                };
                const readNum = (key, defVal) => {
                    const n = Number(localStorage.getItem(key));
                    return Number.isFinite(n) && n > 0 ? Math.floor(n) : defVal;
                };

                const injectAllGroups = readBool('freechat.memory.inject.allGroups', true);
                const injectGroupSessions = readBool('freechat.memory.inject.groupSessions', true);
                // 新键优先：不存在时回退旧键，保持向后兼容
                const maxSessionsPerRequest = readNum('freechat.memory.maxSessionsPerRequest', readNum('freechat.memory.maxConvPerGroup', 10));
                const maxCharsPerItem = readNum('freechat.memory.maxCharsPerItem', readNum('freechat.memory.maxCharsPerSection', 4000));
                // 强制上限以避免一次请求注入过多上下文导致网络/模型延迟（可通过 localStorage 覆盖）
                const effectiveMaxSessions = Math.max(1, Math.min(readNum('freechat.memory.enforcedMaxSessions', 3), maxSessionsPerRequest));
                const effectiveMaxCharsPerItem = Math.max(256, Math.min(readNum('freechat.memory.enforcedMaxCharsPerItem', 1000), maxCharsPerItem));

                const result = [];

                // 辅助：判断是否为低信号或纯寒暄文本
                const isLowSignalOrGreeting = (str) => {
                    try {
                        if (!str) return true;
                        const s = String(str || '').trim();
                        if (s.length < 20) return true;
                        const lowSignals = ['无', 'none', 'no', 'n/a'];
                        if (lowSignals.includes(s)) return true;
                        // 常见寒暄词或感谢语
                        const greetingRe = /^(你好|您好|hi\b|hello\b|thanks|thank you|谢谢|感谢)/i;
                        if (greetingRe.test(s)) return true;
                        return false;
                    } catch (_) { return false; }
                };

                // 辅助：确保记忆条目带有记忆级别前缀（默认 background）
                const ensureMemoryPrefix = (txt) => {
                    try {
                        const t = String(txt || '').trim();
                        if (!t) return '';
                        const tl = t.trim();
                        if (tl.startsWith('【记忆级别:') || tl.startsWith('【背景资料') || tl.toLowerCase().startsWith('[memory-level:')) return t;
                        return `【记忆级别: background】\n${t}`;
                    } catch (_) { return txt; }
                };

                // 分组记忆：逐条生成 system
                try {
                    const groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                    const currentGroupId = currentConversationGroupId || null;
                    const targetGroups = injectAllGroups ? groups : groups.filter(g => g.id === currentGroupId);
                    for (const g of targetGroups) {
                        if (!g || !g.memorySummary) continue;
                        // 过滤低信号或寒暄
                        if (isLowSignalOrGreeting(g.memorySummary)) continue;
                        let text = `[Group Memory] ${g.name || g.id}\n${g.memorySummary}`;
                        if (text.length > effectiveMaxCharsPerItem) {
                            text = text.slice(0, effectiveMaxCharsPerItem) + `\n...（分组记忆超出 ${effectiveMaxCharsPerItem} 字符，已截断）`;
                        }
                        text = ensureMemoryPrefix(text);
                        result.push({ role: 'system', content: text });
                    }
                } catch (_) { /* 忽略分组解析异常 */ }

                // 会话记忆：当前分组内，按更新时间倒序，逐条生成 system
                if (injectGroupSessions) {
                    try {
                        const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                        const gid = currentConversationGroupId || null;
                        const sameGroupConvs = saved
                            .filter(c => (c && (c.groupId || null) === gid) && c.summary)
                            .sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));

                        // 去重：按会话 ID 去重
                        const seenIds = new Set();
                        const deduped = [];
                        for (const c of sameGroupConvs) {
                            const cid = c && c.id;
                            if (!cid) continue;
                            if (seenIds.has(cid)) continue;
                            seenIds.add(cid);
                            deduped.push(c);
                        }

                        const limited = deduped.slice(0, Math.max(1, effectiveMaxSessions));
                        for (const c of limited) {
                            if (!c || !c.summary) continue;
                            // 低信号过滤：避免把“无”或寒暄存入记忆
                            if (isLowSignalOrGreeting(c.summary)) continue;
                            const name = (c && c.name) ? c.name : (c && c.id) ? c.id : '会话';
                            let text = `[Session Memory] ${name}\n${c.summary}`;
                            if (text.length > effectiveMaxCharsPerItem) {
                                text = text.slice(0, effectiveMaxCharsPerItem) + `\n...（会话记忆超出 ${effectiveMaxCharsPerItem} 字符，已截断）`;
                            }
                            text = ensureMemoryPrefix(text);
                            result.push({ role: 'system', content: text });
                        }
                    } catch (_) { /* 忽略会话解析异常 */ }
                }

                return result;
            } catch (_) {
                return [];
            }
        }

        /**
         * 多 system 兼容判定（静态映射版）与合并工具
         * 说明：本阶段仅用于“不支持多 system 时自动合并”为单条
         */
        function inferProviderFromModel(modelName) {
            try {
                if (!modelName) return 'unknown';
                const idx = modelName.indexOf('/');
                return idx > 0 ? modelName.slice(0, idx).toLowerCase() : modelName.toLowerCase();
            } catch (_) {
                return 'unknown';
            }
        }
        const STATIC_MULTI_SYSTEM_SUPPORT = {
            'openai': true,
            'meta-llama': true,
            'mistralai': true,
            'deepseek': true,
            'qwen': true,
            'x-ai': true,
            'minimax': true,      // 保守，后续可配合降级
            'anthropic': false,
            'google': false,
            'cohere': false,
            'ai21': false
        };
        function supportsMultiSystem(modelName) {
            const p = inferProviderFromModel(modelName);
            if (Object.prototype.hasOwnProperty.call(STATIC_MULTI_SYSTEM_SUPPORT, p)) {
                return !!STATIC_MULTI_SYSTEM_SUPPORT[p];
            }
            // 未知：先按支持处理
            return true;
        }
        function mergeSystemMessages(systemMsgs) {
            if (!Array.isArray(systemMsgs) || !systemMsgs.length) return null;
            const sep = '\n\n---\n';
            const content = systemMsgs.map(m => String(m.content || '').trim()).filter(Boolean).join(sep);
            return content ? { role: 'system', content } : null;
        }

        /**
         * （可选）在发送前预生成“当前会话”的会话记忆，使首轮即可注入
         * 通过 localStorage.freechat.memory.preSummarize 控制（'true'|'false'，默认 'false'）
         */
        async function preSummarizeCurrentConversationMaybe() {
            try {
                const need = (localStorage.getItem('freechat.memory.preSummarize') || '').trim() === 'true';
                if (!need) return;
                const conversationId = localStorage.getItem('deepseekConversationId');
                if (!conversationId) return;
                let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const idx = saved.findIndex(c => c.id === conversationId);
                if (idx === -1) return;
                const entry = saved[idx];
                if (entry.summary) return; // 已有会话记忆则跳过

                const apiKey = (window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey'));
                if (!apiKey) return;
                if (!window.PROMPTS || !window.PROMPTS.SESSION_SUMMARY) return;

                const systemPrompt = window.PROMPTS.SESSION_SUMMARY;
                const userContent = (entry.messages || []).map(m => `${(m.role||'').toUpperCase()}: ${m.content||''}`).join('\n');
                // 优先使用会话记录的模型；若缺失则回退到全局模型
                const modelToUse = (entry && entry.model) ? entry.model : (window.MODEL_NAME || 'minimax/minimax-m2:free');
                const url = (window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');

                // 简化：不写日志，失败静默
                const resp = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({ model: modelToUse, messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userContent } ], temperature: 0.2 })
                }, { retries: 2, backoff: 500, timeout: 20000 });
                if (!resp.ok) return;
                const data = await resp.json();
                const summaryText = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : null;
                if (!summaryText) return;
                // 写回会话记忆
                saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const idx2 = saved.findIndex(c => c.id === conversationId);
                if (idx2 !== -1) {
                    saved[idx2].summary = summaryText;
                    saved[idx2].lastSummarizedMessageCount = (entry.messages || []).length;
                    saved[idx2].updatedAt = new Date().toISOString();
                    localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                }
            } catch (_) { /* 预摘要失败忽略 */ }
        }

        /**
         * 设置当前会话分组
         * 功能：更新当前会话所属的分组ID，并保存到localStorage
         * 参数：groupId - 分组ID，为null时表示未分组
         * 返回值：无
         */
        function setCurrentConversationGroup(groupId) {
            currentConversationGroupId = groupId;
            if (groupId) localStorage.setItem('deepseekConversationGroupId', groupId);
            else localStorage.removeItem('deepseekConversationGroupId');
        }

        /**
         * 保存会话
         * 功能：将当前会话数组保存到localStorage
         * 参数：无
         * 返回值：无
         */
        function saveConversation() {
            // 批量写入 deepseekConversation：避免高频流式更新导致 localStorage 同步 I/O 卡顿
            batchedStorageSetJson('deepseekConversation', currentConversation);
        }

        // 简单的 per-key 批量写入器：在短时间内合并多次写入为一次实际 setItem
        const _batchedWrites = Object.create(null);
        function batchedStorageSetJson(key, value, delay = 400) {
            try {
                if (_batchedWrites[key] && _batchedWrites[key].timer) {
                    clearTimeout(_batchedWrites[key].timer);
                }
                _batchedWrites[key] = _batchedWrites[key] || {};
                _batchedWrites[key].value = value;
                _batchedWrites[key].timer = setTimeout(() => {
                    try {
                        localStorage.setItem(key, JSON.stringify(_batchedWrites[key].value));
                    } catch (e) {
                        console.error('batchedStorageSetJson 写入失败：', key, e);
                    } finally {
                        try { clearTimeout(_batchedWrites[key].timer); } catch(_) {}
                        delete _batchedWrites[key];
                    }
                }, delay);
            } catch (e) {
                // 若批量写入逻辑本身异常，则回退到直接写入，避免丢数据
                try { localStorage.setItem(key, JSON.stringify(value)); } catch (_) {}
            }
        }

        /**
         * 取消指定 key 的待写入 batchedStorage（不执行写回）
         * 用途：在加载持久化会话前调用，避免旧快照在延迟写入后覆盖新加载的数据
         */
        function batchedStorageCancelKey(key) {
            try {
                if (_batchedWrites && _batchedWrites[key]) {
                    try { clearTimeout(_batchedWrites[key].timer); } catch (_) {}
                    delete _batchedWrites[key];
                }
            } catch (e) {
                console.error('batchedStorageCancelKey 异常：', e);
            }
        }

        /**
         * 立即将所有待写入项写回 localStorage（可用于页面卸载或切换时保证写回）
         */
        function batchedStorageFlushAll() {
            try {
                if (!_batchedWrites) return;
                for (const k of Object.keys(_batchedWrites)) {
                    try {
                        if (_batchedWrites[k] && typeof _batchedWrites[k].value !== 'undefined') {
                            try { clearTimeout(_batchedWrites[k].timer); } catch(_) {}
                            localStorage.setItem(k, JSON.stringify(_batchedWrites[k].value));
                        }
                    } catch (e) { console.error('batchedStorageFlushAll 写回失败：', k, e); }
                    try { delete _batchedWrites[k]; } catch(_) {}
                }
            } catch (e) { console.error('batchedStorageFlushAll 异常：', e); }
        }

        // 页面卸载前尝试立即写回所有待写入项，减少因导航/刷新导致的数据遗失或覆盖竞态
        try {
            window.addEventListener && window.addEventListener('beforeunload', () => {
                try { batchedStorageFlushAll(); } catch (_) {}
            });
        } catch (_) {}

        /**
         * 更新当前模型徽标
         * 功能：将 window.MODEL_NAME 或 localStorage.chatModel 显示在页面头部徽标处
         * 参数：无
         * 返回值：无
         */
        function updateCurrentModelBadge() {
            const badge = document.getElementById('currentModelBadge');
            if (!badge) return;
            const name = (window.MODEL_NAME || localStorage.getItem('chatModel') || '').trim();
            // 设置文本并确保徽章可见（防止样式或脚本导致被隐藏）
            badge.textContent = name || '未选择模型';
            try {
                badge.style.display = ''; // 恢复到样式表控制的显示模式
                badge.style.visibility = 'visible';
                badge.removeAttribute('hidden');
                badge.setAttribute('aria-hidden', 'false');
                if (!badge.classList.contains('model-badge')) badge.classList.add('model-badge');
                // 同步 title 便于悬停查看完整模型名
                badge.title = badge.textContent || badge.title || '当前模型';
            } catch (_) {}
        }

        /**
         * 渲染会话标题栏（会话名 + 分组名）
         * 优先从持久化 savedDeepseekConversations 中读取 deepseekConversationId 对应条目；
         * 回退到 deepseekNewConversationName / currentConversation.name / 未命名会话
         */
        function renderSessionTitle() {
            try {
                const sessionNameEl = document.getElementById('sessionName');
                const sessionGroupEl = document.getElementById('sessionGroup');
                if (!sessionNameEl || !sessionGroupEl) return;

                const savedConvs = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const currentId = localStorage.getItem('deepseekConversationId');
                let sessionObj = savedConvs.find(c => c && c.id === currentId) || null;

                if (!sessionObj) {
                    const tempName = (localStorage.getItem('deepseekNewConversationName') || '').trim();
                    const tempGroup = localStorage.getItem('deepseekConversationGroupId') || null;
                    sessionObj = tempName ? { name: tempName, groupId: tempGroup } : null;
                }

                const name = sessionObj && sessionObj.name ? sessionObj.name : ((window.currentConversation && window.currentConversation.name) ? window.currentConversation.name : '未命名会话');
                const groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                const gid = (sessionObj && sessionObj.groupId) ? sessionObj.groupId : (localStorage.getItem('deepseekConversationGroupId') || null);
                const group = groups.find(g => g && g.id === gid);
                const groupName = group && group.name ? group.name : '未分组';

                sessionNameEl.textContent = name;
                sessionGroupEl.textContent = groupName;
                try {
                    const memBadge = document.getElementById('memoryStatusBadge');
                    if (memBadge) {
                        const currentId = localStorage.getItem('deepseekConversationId');
                        const jobsAll = (typeof getMemoryJobs === 'function') ? getMemoryJobs() : [];
                        const jobs = jobsAll.filter(j => j && j.conversationId === currentId);
                        if (!jobs || jobs.length === 0) {
                            memBadge.innerHTML = '';
                            memBadge.style.display = 'none';
                        } else {
                            const inProgressCount = jobs.filter(j => j.status === 'in-progress').length;
                            const pendingCount = jobs.filter(j => j.status === 'pending').length;
                            const doneCount = jobs.filter(j => j.status === 'done').length;
                            const failedCount = jobs.filter(j => j.status === 'failed').length;
                            const total = jobs.length;
                            // 根据状态显示：进行中显示旋转半圆环，完成后显示静态整圆环
                            if (inProgressCount > 0) {
                                // 使用 SVG stroke 动画的通用圆环加载器
                                memBadge.innerHTML = '<svg class=\"memory-spinner-svg\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><circle class=\"path\" cx=\"12\" cy=\"12\" r=\"10\" fill=\"none\" stroke-width=\"2\"/></svg>';
                                memBadge.style.display = '';
                            } else if (total > 0) {
                                // 完成态：填充蓝色圆圈并添加白色勾
                                memBadge.innerHTML = '<svg class=\"memory-done\" viewBox=\"0 0 24 24\" aria-hidden=\"true\"><circle cx=\"12\" cy=\"12\" r=\"10\" fill=\"#007aff\"/><path d=\"M8 12.5l2.2 2.2L16 9\" stroke=\"#fff\" stroke-width=\"2\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>';
                                memBadge.style.display = '';
                            } else {
                                memBadge.innerHTML = '';
                                memBadge.style.display = 'none';
                            }
                            // 同步 title 便于悬停查看统计（仅 title，不作为可见文字）
                            memBadge.title = `总:${total} 待:${pendingCount} 中:${inProgressCount} 成:${doneCount} 失:${failedCount}`;
                        }
                    }
                } catch (_) {}
            } catch (e) {
                console.error('renderSessionTitle 失败：', e);
            }
            // 调整标题栏占位高度，防止移动端固定标题遮挡首条消息
            try { adjustSessionTitleHeight(); } catch (_) {}
        }

        /**
         * 持久会话节流更新
         * 功能：将当前会话内容按节流策略写回 savedDeepseekConversations 对应条目，降低频繁写入
         * 参数：无（内部获取 deepseekConversationId）
         * 返回值：无
         */
        const UPSERT_INTERVAL_MS = 1500;
        let upsertTimer = null;
        function upsertSavedConversationNow() {
            const conversationId = localStorage.getItem('deepseekConversationId');
            if (!conversationId) return;
            try {
                // 为减少并发写回覆盖，先读取最新的存储值并基于最新值进行合并/更新（乐观合并）
                try {
                    let latestSaved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                    const idxLatest = latestSaved.findIndex(c => c && c.id === conversationId);
                    if (idxLatest === -1) return;
                    latestSaved[idxLatest].messages = currentConversation.slice();
                    latestSaved[idxLatest].updatedAt = new Date().toISOString();
                    // 同步保存当前使用的模型，保证会话记录模型可被恢复
                    latestSaved[idxLatest].model = window.MODEL_NAME;
                    // 同步保存当前有效的模型参数与（可选）会话级 systemPrompt，便于回溯
                    try {
                        latestSaved[idxLatest].modelParams = getEffectiveModelParams(latestSaved[idxLatest]) || getGlobalModelParams();
                    } catch (_) { latestSaved[idxLatest].modelParams = getGlobalModelParams(); }
                    try {
                        latestSaved[idxLatest].systemPrompt = getEffectiveSystemPrompt(latestSaved[idxLatest]) || '';
                    } catch (_) { latestSaved[idxLatest].systemPrompt = (localStorage.getItem('freechat.systemPrompt')||''); }
                    // 保持分组ID与当前内存一致
                    latestSaved[idxLatest].groupId = currentConversationGroupId || null;
                    try { batchedStorageSetJson('savedDeepseekConversations', latestSaved); } catch (e) { console.error('upsertSavedConversationNow 写入失败：', e); }
                } catch (e) {
                    console.error('upsertSavedConversationNow 合并写入失败：', e);
                }
            } catch (e) {
                console.error('upsertSavedConversationNow 失败：', e);
            }
        }
        function scheduleUpsertSavedConversation() {
            if (upsertTimer) return;
            upsertTimer = setTimeout(() => {
                upsertTimer = null;
                upsertSavedConversationNow();
            }, UPSERT_INTERVAL_MS);
        }

        /**
         * 记忆任务队列（异步后台执行）
         * - 使用 localStorage 键 `memoryJobs` 持久化任务队列，避免刷新丢失
         * - 使用内联 Blob Worker 执行网络请求，主线程负责入队、状态更新与写回
         */
        function getMemoryJobs() {
            try { return JSON.parse(localStorage.getItem('memoryJobs') || '[]'); } catch (_) { return []; }
        }
        function saveMemoryJobs(jobs) {
            try { localStorage.setItem('memoryJobs', JSON.stringify(jobs || [])); } catch (e) { console.error('saveMemoryJobs 写入失败：', e); }
            try { if (typeof updateMemoryBadge === 'function') updateMemoryBadge(); } catch (_) {}
        }
        function _genJobId() { return 'mj_' + Date.now() + '_' + Math.floor(Math.random() * 90000 + 10000); }

        // 将当前会话快照与必要元信息入队，后台 Worker 会使用 job.payload 中的内容发起摘要请求
        function enqueueMemoryJob(conversationId, type = 'session', payload = {}) {
            try {
                // 强制写回会话，确保 worker 使用到最新内容
                try { upsertSavedConversationNow(); } catch (_) {}

                const jobs = getMemoryJobs();
                const job = {
                    id: _genJobId(),
                    conversationId: conversationId || localStorage.getItem('deepseekConversationId') || null,
                    type: type,
                    status: 'pending',
                    attempts: 0,
                    createdAt: new Date().toISOString(),
                    payload: payload // 包含 systemPrompt / userContent / modelToUse / msgCount / groupId 等
                };
                jobs.push(job);
                saveMemoryJobs(jobs);
                // 触发 Worker 开始处理（若未启动则启动）
                startMemoryWorkerIfNeeded();
                return job.id;
            } catch (e) {
                console.error('enqueueMemoryJob 失败：', e);
                return null;
            }
        }

        function startMemoryWorkerIfNeeded() {
            try {
                if (window._memoryWorkerStarted) return;
                // 创建内联 Blob Worker
                const workerCode = `
                    self.onmessage = async function(e) {
                        const job = e.data && e.data.job;
                        if (!job) return;
                        const apiKey = job.payload.apiKey || null;
                        const url = job.payload.url || (self.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');
                        const body = job.payload.requestBody || null;
                        const maxAttempts = job.payload.maxAttempts || 1;
                        let lastErr = null;
                        for (let attempt=0; attempt<maxAttempts; attempt++) {
                            try {
                                const resp = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': apiKey ? ('Bearer ' + apiKey) : '' }, body: JSON.stringify(body) });
                                const data = await resp.json().catch(()=>null);
                                if (!resp.ok) {
                                    lastErr = { status: resp.status, body: data };
                                    continue;
                                }
                                const memoryText = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : null;
                                self.postMessage({ ok: true, jobId: job.id, result: memoryText, final: data });
                                return;
                            } catch (err) {
                                lastErr = String(err || 'fetch_error');
                            }
                        }
                        self.postMessage({ ok: false, jobId: job.id, error: lastErr });
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const w = new Worker(URL.createObjectURL(blob));
                w.addEventListener('message', (ev) => {
                    try {
                        const d = ev.data || {};
                        const jobId = d.jobId;
                        const jobs = getMemoryJobs();
                        const ji = jobs.findIndex(x => x && x.id === jobId);
                        if (d.ok) {
                            if (ji !== -1) {
                                jobs[ji].status = 'done';
                                jobs[ji].attempts = (jobs[ji].attempts || 0) + 1;
                                jobs[ji].finishedAt = new Date().toISOString();
                                saveMemoryJobs(jobs);
                                // 写回会话摘要（主线程执行 localStorage 修改）
                                try {
                                    const payload = jobs[ji].payload || {};
                                    const conversationId = jobs[ji].conversationId;
                                    let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                                    const idx = saved.findIndex(c => c && c.id === conversationId);
                                    if (idx !== -1) {
                                        const msgCountAtJob = payload.msgCount || 0;
                                        const lastCount = saved[idx].lastSummarizedMessageCount || 0;
                                        // 仅在未被更晚摘要覆盖时写回，避免竞态覆盖
                                        if (!saved[idx].summary || msgCountAtJob > lastCount) {
                                            saved[idx].summary = d.result || '';
                                            saved[idx].lastSummarizedMessageCount = msgCountAtJob;
                                            saved[idx].updatedAt = new Date().toISOString();
                                            localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                                            // 若属于分组，则触发分组记忆刷新（异步但不阻塞）
                                            if (saved[idx].groupId) {
                                                try { if (typeof updateGroupMemory === 'function') updateGroupMemory(saved[idx].groupId).catch(()=>{}); } catch(_) {}
                                            }
                                        }
                                    }
                                } catch (e) { console.error('memoryWorker result apply failed:', e); }
                            }
                        } else {
                            if (ji !== -1) {
                                jobs[ji].status = 'failed';
                                jobs[ji].error = d.error || 'unknown';
                                jobs[ji].attempts = (jobs[ji].attempts || 0) + 1;
                                jobs[ji].finishedAt = new Date().toISOString();
                                saveMemoryJobs(jobs);
                            }
                        }
                    } catch (err) { console.error('memoryWorker message handler 失败：', err); }
                });
                window._memoryWorker = w;
                window._memoryWorkerStarted = true;
                // 恢复并分发当前 pending 任务
                try {
                    const pending = getMemoryJobs().filter(j => j && j.status === 'pending');
                    for (const p of pending) {
                        // 标记为 in-progress 并发送
                        const jobs = getMemoryJobs();
                        const i = jobs.findIndex(x => x && x.id === p.id);
                        if (i !== -1) {
                            jobs[i].status = 'in-progress';
                            jobs[i].startedAt = new Date().toISOString();
                            saveMemoryJobs(jobs);
                            // 更新 UI 徽章
                            try { if (typeof updateMemoryBadge === 'function') updateMemoryBadge(); } catch(_) {}
                            window._memoryWorker.postMessage({ job: jobs[i] });
                        }
                    }
                } catch (_) {}
            } catch (e) {
                console.error('startMemoryWorkerIfNeeded 失败：', e);
            }
        }

        // ============ 打字机动画系统 ============

        /**
         * 全局打字机动画控制器
         * 用于管理和中断打字动画
         */
        window._typingAnimations = window._typingAnimations || [];

        /**
         * 逐字符打字机动画效果
         * @param {HTMLElement} element - 目标DOM元素
         * @param {String} htmlContent - 完整的HTML内容（已渲染的Markdown）
         * @param {Object} options - 配置选项
         * @returns {Promise} 动画完成的Promise
         */
        function typewriterEffect(element, htmlContent, options = {}) {
            return new Promise((resolve) => {
                // 配置选项
                const opts = Object.assign({
                    speed: 30, // 每个字符的延迟（毫秒）
                    skipAnimation: false, // 是否跳过动画
                    onComplete: null // 完成回调
                }, options);

                // 如果禁用动画或内容为空，直接显示
                if (opts.skipAnimation || !htmlContent) {
                    element.innerHTML = htmlContent || '';
                    if (opts.onComplete) opts.onComplete();
                    resolve();
                    return;
                }

                // 创建动画控制器
                const controller = {
                    cancelled: false,
                    element: element,
                    cancel: function() {
                        this.cancelled = true;
                        // 立即显示完整内容
                        if (element) element.innerHTML = htmlContent;
                    }
                };
                window._typingAnimations.push(controller);

                // 提取纯文本用于打字（忽略HTML标签）
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                const fullText = tempDiv.textContent || tempDiv.innerText || '';

                // 初始化显示空内容和闪烁光标
                element.innerHTML = '<span class="typing-cursor"></span>';

                let currentIndex = 0;
                let currentHTML = '';

                // 逐字符打字函数
                function typeNextChar() {
                    if (controller.cancelled) {
                        resolve();
                        return;
                    }

                    if (currentIndex >= fullText.length) {
                        // 打字完成，移除光标，显示完整HTML
                        element.innerHTML = htmlContent;
                        if (opts.onComplete) opts.onComplete();

                        // 从动画列表中移除
                        const idx = window._typingAnimations.indexOf(controller);
                        if (idx !== -1) window._typingAnimations.splice(idx, 1);

                        resolve();
                        return;
                    }

                    // 添加下一个字符
                    const char = fullText[currentIndex];
                    currentHTML += char;

                    // 使用简单的文本显示（避免HTML解析复杂度）
                    element.innerHTML = escapeHtml(currentHTML) + '<span class="typing-cursor"></span>';

                    currentIndex++;

                    // 根据字符类型调整速度（中文慢一些，标点快一些）
                    let delay = opts.speed;
                    if (/[\u4e00-\u9fa5]/.test(char)) {
                        delay = opts.speed * 1.2; // 中文稍慢
                    } else if (/[,;:!?，；：！？。、]/.test(char)) {
                        delay = opts.speed * 2; // 标点停顿更长
                    } else if (/\s/.test(char)) {
                        delay = opts.speed * 0.5; // 空格快速
                    }

                    // 使用requestAnimationFrame + setTimeout组合，确保流畅
                    setTimeout(() => {
                        requestAnimationFrame(typeNextChar);
                    }, delay);
                }

                // 开始打字
                requestAnimationFrame(typeNextChar);

                // 点击便签立即显示完整内容
                const clickHandler = () => {
                    controller.cancel();
                    element.removeEventListener('click', clickHandler);
                };
                element.addEventListener('click', clickHandler, { once: true });
            });
        }

        /**
         * HTML转义（防止XSS）
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * 取消所有正在进行的打字动画
         */
        function cancelAllTypingAnimations() {
            if (window._typingAnimations) {
                window._typingAnimations.forEach(ctrl => {
                    try { ctrl.cancel(); } catch (_) {}
                });
                window._typingAnimations = [];
            }
        }

        // ============ 便签收藏功能 ============

        /**
         * 获取所有收藏的便签
         */
        function getFavoriteStickies() {
            return storageGetJson('freechat.favoriteStickies', []);
        }

        /**
         * 保存收藏的便签列表
         */
        function saveFavoriteStickies(favorites) {
            storageSetJson('freechat.favoriteStickies', favorites);
        }

        /**
         * 检查便签是否已收藏
         */
        function isStickyFavorited(favoriteId) {
            const favorites = getFavoriteStickies();
            return favorites.some(f => f.id === favoriteId);
        }

        /**
         * 切换便签收藏状态
         */
        function toggleStickyFavorite(favoriteId, userMsg, assistantMsg, btnElement) {
            const favorites = getFavoriteStickies();
            const existingIndex = favorites.findIndex(f => f.id === favoriteId);

            if (existingIndex !== -1) {
                // 取消收藏
                favorites.splice(existingIndex, 1);
                btnElement.innerHTML = '<i class="far fa-star"></i>';
                btnElement.title = '收藏';
                showToast('已取消收藏', 'info');
            } else {
                // 添加收藏
                const favoriteItem = {
                    id: favoriteId,
                    userContent: userMsg.content,
                    assistantContent: assistantMsg.content,
                    assistantModel: assistantMsg.model || window.MODEL_NAME || 'minimax/minimax-m2:free',
                    reasoning: assistantMsg.reasoning || '',
                    citations: assistantMsg.citations || [],
                    timestamp: new Date().toISOString(),
                    conversationId: currentConversation.id || null
                };
                favorites.unshift(favoriteItem); // 新收藏放在最前面
                btnElement.innerHTML = '<i class="fas fa-star"></i>';
                btnElement.title = '取消收藏';
                showToast('已添加到收藏', 'success');
            }

            saveFavoriteStickies(favorites);
            // 更新侧边栏收藏列表
            updateFavoritesDrawer();
        }

        /**
         * 更新侧边栏收藏列表
         */
        function updateFavoritesDrawer() {
            const favoritesContainer = document.getElementById('favoritesContainer');
            if (!favoritesContainer) return;

            const favorites = getFavoriteStickies();
            if (favorites.length === 0) {
                favoritesContainer.innerHTML = '<div style="color: var(--muted); font-size: 0.9rem; text-align: center; padding: 20px;">暂无收藏</div>';
                return;
            }

            favoritesContainer.innerHTML = '';
            favorites.forEach((fav, index) => {
                const favItem = document.createElement('div');
                favItem.className = 'drawer-item favorite-item';
                favItem.innerHTML = `
                    <div style="font-size: 0.85rem; color: var(--muted); margin-bottom: 4px;">
                        ${fav.userContent.substring(0, 50)}${fav.userContent.length > 50 ? '...' : ''}
                    </div>
                    <div style="font-size: 0.75rem; color: var(--muted); opacity: 0.7;">
                        ${new Date(fav.timestamp).toLocaleString('zh-CN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}
                    </div>
                `;
                favItem.addEventListener('click', () => viewFavoriteSticky(fav));
                favoritesContainer.appendChild(favItem);
            });
        }

        /**
         * 查看收藏的便签
         */
        function viewFavoriteSticky(favorite) {
            // 关闭抽屉
            closeDrawer();

            // 清空当前消息容器，只显示这个收藏的便签
            messageContainer.innerHTML = '';

            // 创建便签卡片
            const stickyCard = document.createElement('div');
            stickyCard.className = 'sticky-note-card';

            // 添加标题提示（查看收藏）
            const viewModeHint = document.createElement('div');
            viewModeHint.style.cssText = 'background: rgba(79,70,229,0.1); border-left: 3px solid var(--brand); padding: 8px 12px; margin-bottom: 12px; font-size: 0.85rem; color: var(--brand); border-radius: 4px;';
            viewModeHint.innerHTML = '<i class="fas fa-star"></i> 收藏查看模式 - <a href="#" onclick="location.reload(); return false;" style="color: var(--brand); text-decoration: underline;">返回会话</a>';
            stickyCard.appendChild(viewModeHint);

            // 用户问题区域
            const questionDiv = document.createElement('div');
            questionDiv.className = 'sticky-question';
            questionDiv.textContent = favorite.userContent;
            stickyCard.appendChild(questionDiv);

            // 分隔线
            const divider = document.createElement('div');
            divider.className = 'sticky-divider';
            stickyCard.appendChild(divider);

            // AI回复区域
            const answerDiv = document.createElement('div');
            answerDiv.className = 'sticky-answer';

            try {
                // 渲染思考过程（如果有）
                if (favorite.reasoning && favorite.reasoning.trim()) {
                    const reasoningBlock = document.createElement('div');
                    reasoningBlock.className = 'reasoning-block';
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'reasoning-toggle';
                    toggleBtn.textContent = '收起思考过程';
                    const rDiv = document.createElement('div');
                    rDiv.className = 'reasoning-content';
                    try {
                        const rHtml = (window.marked ? marked.parse(favorite.reasoning) : favorite.reasoning);
                        rDiv.innerHTML = (window.DOMPurify ? DOMPurify.sanitize(rHtml) : rHtml);
                    } catch (_) {
                        rDiv.textContent = favorite.reasoning;
                    }
                    rDiv.style.display = 'block';
                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const willShow = (rDiv.style.display === 'none');
                        rDiv.style.display = willShow ? 'block' : 'none';
                        toggleBtn.textContent = willShow ? '收起思考过程' : '展开思考过程';
                    });
                    reasoningBlock.appendChild(toggleBtn);
                    reasoningBlock.appendChild(rDiv);
                    answerDiv.appendChild(reasoningBlock);
                }

                // 渲染AI回复内容
                const rawHtml = (window.marked ? marked.parse(favorite.assistantContent) : favorite.assistantContent);
                const cleanHtml = (window.DOMPurify ? DOMPurify.sanitize(rawHtml) : rawHtml);
                const contentHolder = document.createElement('div');
                contentHolder.innerHTML = cleanHtml;
                answerDiv.appendChild(contentHolder);

                // 渲染引用来源（如果有）
                if (favorite.citations && favorite.citations.length > 0) {
                    try {
                        const anns = favorite.citations.filter(x => x && x.type === 'url_citation' && x.url_citation && x.url_citation.url);
                        const citeBlock = buildCitationsElement(anns);
                        if (citeBlock) {
                            answerDiv.appendChild(citeBlock);
                        }
                    } catch (_) {}
                }
            } catch (e) {
                console.error('渲染收藏便签失败：', e);
                answerDiv.textContent = favorite.assistantContent;
            }

            stickyCard.appendChild(answerDiv);

            // 便签底部元信息
            const metaDiv = document.createElement('div');
            metaDiv.className = 'sticky-meta';
            const modelLabel = document.createElement('span');
            modelLabel.className = 'sticky-model-label';
            modelLabel.textContent = favorite.assistantModel;
            metaDiv.appendChild(modelLabel);
            const timestamp = document.createElement('span');
            timestamp.className = 'sticky-timestamp';
            timestamp.textContent = new Date(favorite.timestamp).toLocaleString('zh-CN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
            metaDiv.appendChild(timestamp);
            stickyCard.appendChild(metaDiv);

            // 操作按钮
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'sticky-actions';

            const unfavoriteBtn = document.createElement('button');
            unfavoriteBtn.className = 'sticky-action-btn';
            unfavoriteBtn.innerHTML = '<i class="fas fa-star"></i>';
            unfavoriteBtn.title = '取消收藏';
            unfavoriteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleStickyFavorite(favorite.id, { content: favorite.userContent }, { content: favorite.assistantContent }, unfavoriteBtn);
                // 刷新页面返回会话
                setTimeout(() => location.reload(), 500);
            });

            const copyBtn = document.createElement('button');
            copyBtn.className = 'sticky-action-btn';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.title = '复制回复';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                copyToClipboard(favorite.assistantContent);
            });

            actionsDiv.appendChild(unfavoriteBtn);
            actionsDiv.appendChild(copyBtn);
            stickyCard.appendChild(actionsDiv);

            messageContainer.appendChild(stickyCard);
            scrollToBottom();
        }

        /**
         * 渲染消息列表（复古便签纸风格，问答配对）
         * 功能：将当前会话中的消息渲染为便签纸样式，用户问题和AI回复配对显示在同一张便签上
         * 参数：skipTypewriterAnimation - 是否跳过打字机动画（加载历史会话时应为true）
         * 返回值：无
         */
        function renderMessages(skipTypewriterAnimation = false) {
            // 取消所有进行中的打字动画
            cancelAllTypingAnimations();
            messageContainer.innerHTML = '';
            // 为了减少移动端 DOM 节点数量，限制一次渲染的消息数
            const maxRender = Math.max(20, Number(localStorage.getItem('freechat.ui.maxRenderedMessages') || 200));
            const start = Math.max(0, currentConversation.length - maxRender);

            // 如果刚加载会话，跳过打字机动画
            const skipAnimation = skipTypewriterAnimation || !!window._justLoadedConversation;

            // 问答配对逻辑：遍历消息，识别user-assistant对
            let i = start;
            while (i < currentConversation.length) {
                const message = currentConversation[i];
                const nextMessage = (i + 1 < currentConversation.length) ? currentConversation[i + 1] : null;

                // 情况1：user消息后紧跟assistant消息 -> 配对为一张便签
                if (message.role === 'user' && nextMessage && nextMessage.role === 'assistant') {
                    renderStickyNotePair(message, i, nextMessage, i + 1, skipAnimation);
                    i += 2; // 跳过已配对的两条消息
                }
                // 情况2：单独的消息（未配对）-> 使用传统样式
                else {
                    renderSingleMessage(message, i);
                    i += 1;
                }
            }

            // 渲染完成后清除标志
            if (window._justLoadedConversation) {
                delete window._justLoadedConversation;
            }

            scrollToBottom();
        }

        /**
         * 渲染一对问答为便签纸样式
         * @param {Object} userMsg - 用户消息对象
         * @param {Number} userIdx - 用户消息索引
         * @param {Object} assistantMsg - AI回复消息对象
         * @param {Number} assistantIdx - AI回复消息索引
         * @param {Boolean} skipTypewriterAnimation - 是否跳过打字机动画
         */
        function renderStickyNotePair(userMsg, userIdx, assistantMsg, assistantIdx, skipTypewriterAnimation = false) {
            // 创建便签卡片容器
            const stickyCard = document.createElement('div');
            stickyCard.className = 'sticky-note-card';

            // 用户问题区域
            const questionDiv = document.createElement('div');
            questionDiv.className = 'sticky-question';
            questionDiv.textContent = userMsg.content || '';
            stickyCard.appendChild(questionDiv);

            // 分隔线
            const divider = document.createElement('div');
            divider.className = 'sticky-divider';
            stickyCard.appendChild(divider);

            // AI回复区域
            const answerDiv = document.createElement('div');
            answerDiv.className = 'sticky-answer';

            try {
                // 渲染思考过程（如果有）
                const reasoningText = (assistantMsg.reasoning || '').trim();
                if (reasoningText) {
                    const reasoningBlock = document.createElement('div');
                    reasoningBlock.className = 'reasoning-block';
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'reasoning-toggle';
                    toggleBtn.textContent = '收起思考过程';
                    const rDiv = document.createElement('div');
                    rDiv.className = 'reasoning-content';
                    try {
                        const rHtml = (window.marked ? marked.parse(reasoningText) : reasoningText);
                        rDiv.innerHTML = (window.DOMPurify ? DOMPurify.sanitize(rHtml) : rHtml);
                    } catch (_) {
                        rDiv.textContent = reasoningText;
                    }
                    rDiv.style.display = 'block';
                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const willShow = (rDiv.style.display === 'none');
                        rDiv.style.display = willShow ? 'block' : 'none';
                        toggleBtn.textContent = willShow ? '收起思考过程' : '展开思考过程';
                    });
                    reasoningBlock.appendChild(toggleBtn);
                    reasoningBlock.appendChild(rDiv);
                    answerDiv.appendChild(reasoningBlock);
                }

                // 渲染AI回复内容（Markdown）
                const rawHtml = (window.marked ? marked.parse(assistantMsg.content || '') : assistantMsg.content || '');
                const cleanHtml = (window.DOMPurify ? DOMPurify.sanitize(rawHtml) : rawHtml);
                const contentHolder = document.createElement('div');
                answerDiv.appendChild(contentHolder);

                // 应用打字机动画逻辑：
                // 1. 加载历史会话时（skipTypewriterAnimation=true）：所有消息都不应用打字机动画
                // 2. 正在流式输出时（window._sendingInProgress=true）：所有消息都不应用打字机动画，避免历史消息重新播放
                // 3. 正常渲染时：除了最后一条消息外，其他历史消息可以应用打字机动画（如果用户启用了该功能）
                const isLastMessage = assistantIdx === currentConversation.length - 1;
                const enableTyping = localStorage.getItem('freechat.ui.typewriterAnimation') !== 'false'; // 默认启用
                const isStreaming = !!window._sendingInProgress; // 是否正在流式输出
                // 只有在非加载、非流式输出、非最后一条消息时才应用打字机动画
                const shouldAnimate = enableTyping && !isLastMessage && !skipTypewriterAnimation && !isStreaming;

                if (shouldAnimate) {
                    // 使用打字机动画显示内容
                    typewriterEffect(contentHolder, cleanHtml, {
                        speed: 30,
                        skipAnimation: false
                    });
                } else {
                    // 立即显示完整内容
                    contentHolder.innerHTML = cleanHtml;
                }

                // 渲染引用来源（如果有）
                try {
                    const anns = (assistantMsg.citations || []).filter(x => x && x.type === 'url_citation' && x.url_citation && x.url_citation.url);
                    const citeBlock = buildCitationsElement(anns);
                    if (citeBlock) {
                        const contentText = (answerDiv && answerDiv.innerText) ? answerDiv.innerText : '';
                        if (!/参考来源/.test(contentText)) {
                            if (!answerDiv.querySelector('.citations')) {
                                answerDiv.appendChild(citeBlock);
                            }
                        }
                    }
                } catch (_) { /* 忽略引用渲染异常 */ }
            } catch (e) {
                console.error('Markdown 渲染失败，退回纯文本显示：', e);
                answerDiv.textContent = assistantMsg.content;
            }

            stickyCard.appendChild(answerDiv);

            // 便签底部元信息
            const metaDiv = document.createElement('div');
            metaDiv.className = 'sticky-meta';

            const modelLabel = document.createElement('span');
            modelLabel.className = 'sticky-model-label';
            modelLabel.textContent = assistantMsg.model || window.MODEL_NAME || 'minimax/minimax-m2:free';
            metaDiv.appendChild(modelLabel);

            const timestamp = document.createElement('span');
            timestamp.className = 'sticky-timestamp';
            timestamp.textContent = new Date().toLocaleString('zh-CN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
            metaDiv.appendChild(timestamp);

            stickyCard.appendChild(metaDiv);

            // 操作按钮
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'sticky-actions';

            // 收藏按钮
            const favoriteBtn = document.createElement('button');
            favoriteBtn.className = 'sticky-action-btn';
            const favoriteId = `${userIdx}-${assistantIdx}`;
            const isFavorited = isStickyFavorited(favoriteId);
            favoriteBtn.innerHTML = isFavorited ? '<i class="fas fa-star"></i>' : '<i class="far fa-star"></i>';
            favoriteBtn.title = isFavorited ? '取消收藏' : '收藏';
            favoriteBtn.dataset.favoriteId = favoriteId;
            favoriteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleStickyFavorite(favoriteId, userMsg, assistantMsg, favoriteBtn);
            });

            const copyBtn = document.createElement('button');
            copyBtn.className = 'sticky-action-btn';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.title = '复制回复';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                copyToClipboard(assistantMsg.content);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'sticky-action-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.title = '删除这对问答';
            deleteBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                const confirmed = await showConfirmModal('确定要删除这对问答吗？');
                if (confirmed) {
                    // 删除两条消息（从后往前删除，避免索引变化）
                    deleteMessage(assistantIdx);
                    deleteMessage(userIdx);
                }
            });

            actionsDiv.appendChild(favoriteBtn);
            actionsDiv.appendChild(copyBtn);
            actionsDiv.appendChild(deleteBtn);
            stickyCard.appendChild(actionsDiv);

            messageContainer.appendChild(stickyCard);
        }

        /**
         * 渲染单条消息（未配对的情况，使用传统样式）
         * @param {Object} message - 消息对象
         * @param {Number} index - 消息索引
         */
        function renderSingleMessage(message, index) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${message.role === 'user' ? 'user-message' : 'ai-message'}`;

            if (message.role === 'assistant') {
                try {
                    messageElement.innerHTML = '';
                    const reasoningText = (message.reasoning || '').trim();
                    if (reasoningText) {
                        const reasoningBlock = document.createElement('div');
                        reasoningBlock.className = 'reasoning-block';
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'reasoning-toggle';
                        toggleBtn.textContent = '收起思考过程';
                        const rDiv = document.createElement('div');
                        rDiv.className = 'reasoning-content';
                        try {
                            const rHtml = (window.marked ? marked.parse(reasoningText) : reasoningText);
                            rDiv.innerHTML = (window.DOMPurify ? DOMPurify.sanitize(rHtml) : rHtml);
                        } catch (_) {
                            rDiv.textContent = reasoningText;
                        }
                        rDiv.style.display = 'block';
                        toggleBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const willShow = (rDiv.style.display === 'none');
                            rDiv.style.display = willShow ? 'block' : 'none';
                            toggleBtn.textContent = willShow ? '收起思考过程' : '展开思考过程';
                        });
                        reasoningBlock.appendChild(toggleBtn);
                        reasoningBlock.appendChild(rDiv);
                        messageElement.appendChild(reasoningBlock);
                    }
                    const rawHtml = (window.marked ? marked.parse(message.content || '') : message.content || '');
                    const cleanHtml = (window.DOMPurify ? DOMPurify.sanitize(rawHtml) : rawHtml);
                    const contentHolder = document.createElement('div');
                    contentHolder.innerHTML = cleanHtml;
                    messageElement.appendChild(contentHolder);
                    try {
                        const anns = (message.citations || []).filter(x => x && x.type === 'url_citation' && x.url_citation && x.url_citation.url);
                        const citeBlock = buildCitationsElement(anns);
                        if (citeBlock) {
                            const contentText = (messageElement && messageElement.innerText) ? messageElement.innerText : '';
                            if (!/参考来源/.test(contentText)) {
                                if (!messageElement.querySelector('.citations')) {
                                    messageElement.appendChild(citeBlock);
                                }
                            }
                        }
                    } catch (_) { /* 忽略引用渲染异常 */ }
                } catch (e) {
                    console.error('Markdown 渲染失败，退回纯文本显示：', e);
                    messageElement.textContent = message.content;
                }
            } else {
                messageElement.textContent = message.content;
            }

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            if (message.role === 'assistant') {
                try {
                    const modelLabel = document.createElement('div');
                    modelLabel.className = 'message-model';
                    modelLabel.textContent = (message.model || window.MODEL_NAME || 'minimax/minimax-m2:free');
                    actionsDiv.appendChild(modelLabel);
                } catch (_) {}
            }
            const copyBtn = document.createElement('button');
            copyBtn.className = 'action-btn';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.addEventListener('click', (e) => { e.stopPropagation(); copyToClipboard(message.content); });
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'action-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteMessage(index); });
            actionsDiv.appendChild(copyBtn);
            actionsDiv.appendChild(deleteBtn);
            messageElement.appendChild(actionsDiv);
            messageContainer.appendChild(messageElement);
        }

        /**
         * 发送消息
         * 功能：获取用户输入的消息，添加到会话中，调用API获取AI响应，实时更新界面
         * 参数：无
         * 返回值：Promise，无返回值
         */
        async function sendMessage() {
            console.log('sendMessage invoked');
            // 并发保护：若已有发送在进行中则直接提示并返回
            if (window._sendingInProgress) {
                try { showStatus('正在发送中，请稍候'); setTimeout(hideStatus, 1200); } catch (_) {}
                return;
            }
            window._sendingInProgress = true;
            try {
                // 在发送期间禁用发送按钮，防止用户重复触发并发发送
                if (sendBtn) sendBtn.disabled = true;
                const messageText = messageInput.value.trim();
                console.log('messageText length:', messageText.length);
                if (!messageText) {
                    // 若为空则立即恢复发送按钮状态并返回
                    if (sendBtn) sendBtn.disabled = false;
                    window._sendingInProgress = false;
                    return;
                }
                // 增加发送中样式提示（图标旋转）
                if (sendBtn) sendBtn.classList.add('sending');

                const apiKey = OPENROUTER_API_KEY;
                console.log('using built-in OPENROUTER_API_KEY present:', !!apiKey);
                if (!apiKey) {
                    showStatus('内置 API Key 未配置，无法发送请求');
                    return;
                }

                currentConversation.push({ role: 'user', content: messageText });
                messageInput.value = '';
                saveConversation();

                // 若这是当前页面内首次发送（尚无持久会话ID），则自动创建持久会话条目
                try {
                    const existingId = localStorage.getItem('deepseekConversationId');
                    if (!existingId) {
                        const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                        const newId = Date.now().toString();
                        // 优先使用会话管理页预先输入的名称；否则回退为首条消息前缀
                        const presetNameRaw = (localStorage.getItem('deepseekNewConversationName') || '').trim();
                        const namePrefix = presetNameRaw || (messageText.slice(0, 20) || '新会话');
                        const selectedModelForAutoCreate = localStorage.getItem('deepseekNewConversationModel') || localStorage.getItem('chatModel') || window.MODEL_NAME || 'minimax/minimax-m2:free';
                        const newEntry = {
                            id: newId,
                            name: namePrefix,
                            messages: JSON.parse(localStorage.getItem('deepseekConversation') || '[]'),
                            summary: null,
                            groupId: currentConversationGroupId || null,
                            model: selectedModelForAutoCreate || window.MODEL_NAME,
                            modelParams: (function(){
                                try {
                                    const tmp = localStorage.getItem('deepseekConversationModelParams') || localStorage.getItem('freechat.modelParams') || null;
                                    return tmp ? JSON.parse(tmp) : null;
                                } catch (_) { try { return JSON.parse(localStorage.getItem('freechat.modelParams')||'null'); } catch(e){ return null; } }
                            })(),
                            systemPrompt: (function(){ try { return localStorage.getItem('freechat.systemPrompt') || ''; } catch(_) { return ''; } })(),
                            updatedAt: new Date().toISOString(),
                            lastSummarizedMessageCount: 0
                        };
                        saved.push(newEntry);
                        localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                        localStorage.setItem('deepseekConversationId', newId);
                        try { renderSessionTitle(); } catch (_) {}
                        // 将自动创建时选中的模型同步为全局模型（即时生效）
                        try {
                            if (selectedModelForAutoCreate) {
                                try { localStorage.setItem('chatModel', selectedModelForAutoCreate); } catch(_) {}
                                try { window.MODEL_NAME = selectedModelForAutoCreate; } catch(_) {}
                                try { updateCurrentModelBadge(); } catch(_) {}
                            }
                        } catch (_) {}
                        // 清理临时名称键，避免影响下一次新建
                        try { localStorage.removeItem('deepseekNewConversationName'); } catch (_) {}
                        // 创建后清理临时模型选择（若存在）
                        try { localStorage.removeItem('deepseekNewConversationModel'); } catch (_) {}
                    }
                } catch (e) {
                    console.error('自动创建持久会话失败：', e);
                }
                // 节流写回持久会话
                scheduleUpsertSavedConversation();

                // 记录当前轮是否展示思考过程（仅影响渲染，不改变请求）
                window._reasoningEnabledSend = (localStorage.getItem('freechat.reasoning.show') || 'true') === 'true';

                showStatus('发送中...', true);
                if (sendBtn) sendBtn.style.display = 'none';
                stopBtn.style.display = 'flex';

                // 重置本轮思考过程缓存
                window._currentAssistantReasoning = '';
                window._reasoningCollapsed = false; // 默认展开
                const aiMsgObj = { role: 'assistant', content: '', reasoning: '', model: getCurrentModel() };
                currentConversation.push(aiMsgObj);
                saveConversation();
                scheduleUpsertSavedConversation();
                // 只渲染一次：添加用户消息和空的AI消息后统一渲染，避免重复渲染导致历史消息闪烁
                renderMessages();
                renderWelcomeIfEmpty();

                // 记录日志：开始一个聊天请求事件（请求体稍后在 fetch 中补全）
                let _chatEvtId = null;
                try {
                    _chatEvtId = (window.Logger && window.Logger.start({
                        type: 'chat_request',
                        endpoint: window.DEEPSEEK_API_URL,
                        model: getCurrentModel(),
                        req: { headersMasked: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ***masked***' } }
                    })) || null;
                } catch (_) { /* 忽略日志异常 */ }

                await fetchDeepSeekResponseStream(apiKey, messageText, aiMsgObj, _chatEvtId);
                // 注意：fetchDeepSeekResponseStream 内负责在流结束后保存与渲染
                // 清理发送中样式与 UI（通常在流结束后执行）
                try {
                    if (sendBtn) sendBtn.classList.remove('sending');
                    stopBtn.style.display = 'none';
                    if (sendBtn) sendBtn.style.display = 'flex';
                    hideStatus();
                    saveConversation();
                    // 流式输出结束后不需要再次全量渲染，因为内容已经通过 doUpdateLastAssistantMessage 实时更新
                    // renderMessages(); // 注释掉，避免重新渲染导致历史消息闪烁
                    renderWelcomeIfEmpty();
                } catch (_) {}
                if (sendBtn) sendBtn.disabled = false;
                } catch (error) {
                console.error('发送消息失败:', error);
                showStatus('发送失败：' + (error && error.message ? error.message : '请重试'));
                setTimeout(hideStatus, 5000);
                stopBtn.style.display = 'none';
                if (sendBtn) sendBtn.style.display = 'flex';
                // 清理发送状态
                if (sendBtn) {
                    sendBtn.classList.remove('sending');
                    sendBtn.disabled = false;
                }
                // 记录错误
                try { window.Logger && window.Logger.error({ endpoint: window.DEEPSEEK_API_URL, model: getCurrentModel() }, error); } catch (_) {}
            } finally {
                // 无论成功或失败，解除发送锁（若还有未完成请求，fetchDeepSeekResponseStream 会在结束时清理 controller）
                window._sendingInProgress = false;
                // 确保 current controller 在已中止或完成后被清理
                if (window._currentRequestController && window._currentRequestController.signal && window._currentRequestController.signal.aborted) {
                    window._currentRequestController = null;
                }
            }
        }

        /**
         * 停止生成
         * 功能：停止AI消息的流式生成，隐藏停止按钮并显示状态提示
         * 参数：无
         * 返回值：无
         */
        function stopGeneration() {
            console.log("生成已中止");
            // 真正中止正在进行的请求（若存在）
            try {
                if (window._currentRequestController && typeof window._currentRequestController.abort === 'function') {
                    window._currentRequestController.abort();
                }
            } catch (e) { console.debug('中止请求时出错：', e); }
            window._currentRequestController = null;
            window._sendingInProgress = false;
            showStatus('已中止生成');
            stopBtn.style.display = 'none';
            if (sendBtn) {
                sendBtn.style.display = 'flex';
                sendBtn.classList.remove('sending');
                sendBtn.disabled = false;
            }
        }

        /**
         * 流式获取AI响应
         * 功能：向API发送请求，接收流式响应数据，实时更新AI消息内容
         * 参数：apiKey - API密钥，userMessage - 用户消息（已包含在currentConversation中，此参数暂未使用），aiMsgObj - AI消息对象，用于更新内容
         * 返回值：Promise，无返回值
         */
        async function fetchDeepSeekResponseStream(apiKey, userMessage, aiMsgObj, chatEvtId) {
            // 使用 currentConversation 的可用消息作为请求体。sendMessage 已经把用户消息加入 currentConversation，
            // 因此不需要再次追加 userMessage，避免重复发送同一条用户消息导致模型重复响应或上下文膨胀。
            const messagesPayload = currentConversation.filter(msg => msg.role !== 'assistant' || msg.content);

            // 可选：在发送前尝试预摘要当前会话，确保首轮也可注入会话摘要
            try { await preSummarizeCurrentConversationMaybe(); } catch (_) { /* 忽略预摘要异常 */ }

            // 构造记忆注入：支持可配置注入顺序（localStorage.freechat.memory.injection.order）
            // 可选字段：'web','groups','sessions','messages'（messages 表示历史消息）
            let systemPrompts = [];
            try { systemPrompts = await buildMemorySystemPrompts(); } catch (_) { systemPrompts = []; }
            let webEnabledFlag = (localStorage.getItem('freechat.web.enable') || 'false') === 'true';
            // 限速与计费提示：防止频繁触发联网检索带来高额费用
            try {
                if (webEnabledFlag) {
                    const cooldownMs = Number(localStorage.getItem('freechat.web.cooldownMs')) || 5000;
                    const lastTs = Number(localStorage.getItem('freechat.web.lastTriggeredTs') || 0);
                    const nowTs = Date.now();
                    if (lastTs && (nowTs - lastTs) < cooldownMs) {
                        // 本次请求临时禁用 Web 插件以节流
                        webEnabledFlag = false;
                        try { showStatus('联网搜索短时间内已使用，已临时关闭以节省费用'); setTimeout(hideStatus, 1800); } catch (_) {}
                    } else {
                        localStorage.setItem('freechat.web.lastTriggeredTs', String(nowTs));
                        // 显示估算费用（基于 freechat.web.maxResults 与 $4/1000 计价假设）
                        const maxResultsRaw = Number(localStorage.getItem('freechat.web.maxResults')) || 5;
                        const costPerResult = 4.0 / 1000.0; // 约 $0.004/result
                        const est = (Number.isFinite(maxResultsRaw) ? maxResultsRaw : 5) * costPerResult;
                        try { showStatus(`联网搜索将额外消耗约 $${est.toFixed(3)} 美元，请留意`); setTimeout(hideStatus, 2200); } catch (_) {}
                    }
                }
            } catch (_) {}
            const injectionOrderRaw = (localStorage.getItem('freechat.memory.injection.order') || '').trim();
            const injectionOrder = injectionOrderRaw ? injectionOrderRaw.split(',').map(s => s.trim()).filter(Boolean) : ['web','groups','sessions','messages'];
            const injectedMsgs = [];

            const pushWeb = () => {
                if (!webEnabledFlag) return;
                try {
                    const webSynthPrompt = buildWebSynthesisPrompt();
                    if (webSynthPrompt) injectedMsgs.push({ role: 'system', content: webSynthPrompt });
                } catch (_) { /* 忽略 */ }
            };
            const pushGroupsAndSessions = () => {
                if (Array.isArray(systemPrompts) && systemPrompts.length) {
                    for (const sm of systemPrompts) {
                        try {
                            if (window.PROMPTS && window.PROMPTS.MEMORY_INJECTION) {
                                injectedMsgs.push({ role: 'system', content: window.PROMPTS.MEMORY_INJECTION });
                            }
                        } catch (_) { /* 忽略 */ }
                        if (sm && sm.role === 'system' && sm.content) injectedMsgs.push(sm);
                    }
                }
            };
            // 按配置顺序注入
            for (const key of injectionOrder) {
                if (key === 'web') pushWeb();
                else if (key === 'groups' || key === 'sessions') {
                    // groups/sessions 均由 buildMemorySystemPrompts 返回的 systemPrompts 顺序承载（它内部已区分）
                    pushGroupsAndSessions();
                } else if (key === 'messages') {
                    // messages 表示保留历史消息（在后面合并到请求体）
                }
            }
            // 根据供应商能力决定是否需要将多条 system 合并为单条
            const allMessages = injectedMsgs.length ? injectedMsgs.concat(messagesPayload) : messagesPayload;
            const provider = inferProviderFromModel(getCurrentModel());
            const systemCount = injectedMsgs.filter(m => m && m.role === 'system').length;
            let messagesForRequest = allMessages;
            let _sysMerged = false;
            if (!supportsMultiSystem(getCurrentModel()) && systemCount > 0) {
                const systems = injectedMsgs.filter(m => m && m.role === 'system');
                const others = allMessages.filter(m => m && m.role !== 'system');
                const merged = mergeSystemMessages(systems);
                messagesForRequest = [ merged, ...others ].filter(Boolean);
                _sysMerged = true;
            }

            // 使用有效参数：优先会话级，其次全局，最后兜底默认
            try {
                const convId = localStorage.getItem('deepseekConversationId');
                let convObj = null;
                if (convId) {
                    try { convObj = (JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]') || []).find(c => c && c.id === convId) || null; } catch (_) { convObj = null; }
                }
                const effectiveParams = getEffectiveModelParams(convObj);
                const effectiveSystemPrompt = getEffectiveSystemPrompt(convObj);
                const messagesWithSystem = effectiveSystemPrompt ? [ { role: 'system', content: effectiveSystemPrompt } ].concat(messagesForRequest) : messagesForRequest;
                var requestBody = {
                    model: getCurrentModel(),
                    messages: messagesWithSystem,
                    temperature: (typeof effectiveParams.temperature !== 'undefined') ? effectiveParams.temperature : 0.7,
                    top_p: (typeof effectiveParams.top_p !== 'undefined') ? effectiveParams.top_p : 0.9,
                    max_tokens: (typeof effectiveParams.max_tokens !== 'undefined') ? effectiveParams.max_tokens : 1024,
                    // 本项目默认始终使用流式输出（streaming）
                    stream: true
                };
            } catch (e) {
                console.error('构建请求体时使用参数失败，回退默认值：', e);
                var requestBody = {
                    model: getCurrentModel(),
                    messages: messagesForRequest,
                    temperature: 0.7,
                    top_p: 0.9,
                    max_tokens: 1024,
                    stream: true
                };
            }

            // 按开关注入 OpenRouter Web 插件与搜索上下文选项
            try {
                const webEnabled = (localStorage.getItem('freechat.web.enable') || 'false') === 'true';
                if (webEnabled) {
                    const engine = (localStorage.getItem('freechat.web.engine') || 'auto').trim();
                    const maxResultsRaw = Number(localStorage.getItem('freechat.web.maxResults'));
                    const maxResults = Number.isFinite(maxResultsRaw) ? Math.max(1, Math.min(10, Math.floor(maxResultsRaw))) : 5;
                    const searchPrompt = (localStorage.getItem('freechat.web.searchPrompt') || '').trim();
                    const ctx = (localStorage.getItem('freechat.web.contextSize') || '').trim();

                    const webPlugin = { id: 'web' };
                    if (engine === 'native' || engine === 'exa') webPlugin.engine = engine;
                    if (maxResults) webPlugin.max_results = maxResults;
                    if (searchPrompt) webPlugin.search_prompt = searchPrompt;
                    requestBody.plugins = [ webPlugin ];

                    if (ctx === 'low' || ctx === 'medium' || ctx === 'high') {
                        requestBody.web_search_options = { search_context_size: ctx };
                    }
                }
            } catch (_) { /* 忽略组装失败，不影响主流程 */ }

            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            };

            // 在发起请求前，把最终请求体与 system 注入信息补充到日志
            try {
                window.Logger && chatEvtId && window.Logger.append(chatEvtId, {
                    req: { body: requestBody },
                    sys: { count: systemCount, merged: _sysMerged, provider }
                });
            } catch (_) {}

            // 创建可中止控制器，以支持停止按钮真正中止请求/流
            const controller = new AbortController();
            window._currentRequestController = controller;
            let response;
            try {
                response = await fetch(DEEPSEEK_API_URL, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
            } catch (err) {
                // 若为中止错误，安静退出（用户已触发 stop）并记录日志；否则抛出以供上层处理
                if (err && err.name === 'AbortError') {
                    try { window.Logger && chatEvtId && window.Logger.end(chatEvtId, { error: { message: '请求被用户中止' } }); } catch (_) {}
                    console.log('请求已被中止（AbortError）');
                    // 清理 controller 状态与 UI（stopGeneration 也会处理 UI）
                    window._currentRequestController = null;
                    return;
                }
                throw err;
            }

            if (!response.ok) {
                let errText = '';
                try { errText = await response.text(); } catch (e) { errText = '<无法读取响应体>'; }
                console.error('API 请求失败，status=', response.status, 'body=', errText);
                // 失败也写入日志并结束
                try { window.Logger && chatEvtId && window.Logger.end(chatEvtId, { res: { status: response.status, final: errText }, error: { message: 'API请求失败' } }); } catch (_) {}
                throw new Error(`API请求失败: ${response.status} ${response.statusText} ${errText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            let finished = false;

            // 记录成功返回的状态码
            try { window.Logger && chatEvtId && window.Logger.append(chatEvtId, { res: { status: response.status } }); } catch (_) {}

            while (!finished) {
                const { value, done } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });

                const parts = buffer.split('\n\n');
                buffer = parts.pop();

                for (const part of parts) {
                    const line = part.trim();
                    if (!line) continue;
                    const lines = line.split('\n').map(l => l.trim()).filter(Boolean);
                    for (const l of lines) {
                        if (!l.startsWith('data:')) continue;
                        const data = l.slice(5).trim();
                        if (data === '[DONE]') {
                            finished = true;
                            break;
                        }
                        try {
                            // 优先使用内联 Web Worker 解析流片段，减少主线程 JSON.parse 开销
                            const parseWithWorker = (text) => {
                                return new Promise((resolve, reject) => {
                                    try {
                                        if (!window._streamParserWorker) {
                                            const workerCode = `
                                                self.onmessage = function(e) {
                                                    try {
                                                        const txt = e.data;
                                                        const parsed = JSON.parse(txt);
                                                        const out = {};
                                                        out.detectedModel = parsed.model || parsed.model_name || (parsed.choices && parsed.choices[0] && (parsed.choices[0].model || (parsed.choices[0].message && parsed.choices[0].message.model)));
                                                        out.delta = parsed.choices && parsed.choices[0] && (parsed.choices[0].delta ? parsed.choices[0].delta.content : (parsed.choices[0].text || ''));
                                                        out.rDelta = (parsed.choices && parsed.choices[0] && parsed.choices[0].delta && (parsed.choices[0].delta.reasoning_content || (parsed.choices[0].delta.reasoning && (parsed.choices[0].delta.reasoning.content || parsed.choices[0].delta.reasoning)))) || (parsed.choices && parsed.choices[0] && parsed.choices[0].message && parsed.choices[0].message.reasoning_content) || '';
                                                        out.annDelta = parsed.choices && parsed.choices[0] && parsed.choices[0].delta && parsed.choices[0].delta.annotations;
                                                        out.finalMsg = parsed.choices && parsed.choices[0] && parsed.choices[0].message;
                                                        self.postMessage({ ok: true, out });
                                                    } catch (err) { self.postMessage({ ok: false, err: String(err) }); }
                                                };
                                            `;
                                            const blob = new Blob([workerCode], { type: 'application/javascript' });
                                            window._streamParserWorker = new Worker(URL.createObjectURL(blob));
                                        }
                                        const w = window._streamParserWorker;
                                        const onmsg = (ev) => {
                                            w.removeEventListener('message', onmsg);
                                            if (ev && ev.data && ev.data.ok) resolve(ev.data.out);
                                            else reject((ev && ev.data && ev.data.err) || 'worker parse failed');
                                        };
                                        w.addEventListener('message', onmsg);
                                        w.postMessage(text);
                                    } catch (e) { reject(e); }
                                });
                            };

                            let parsed = null;
                            try { parsed = await parseWithWorker(data); } catch (e) {
                                try { parsed = JSON.parse(data); } catch (err) { parsed = null; }
                            }
                            if (!parsed) continue;
                            // 模型信息
                            try {
                                const detectedModel = parsed.detectedModel;
                                if (detectedModel) {
                                    aiMsgObj.model = detectedModel;
                                    updateLastAssistantMessage(aiMsgObj.content);
                                }
                            } catch (_) {}
                            try { window.Logger && chatEvtId && window.Logger.append(chatEvtId, { type: 'chat_stream', res: { streamChunks: [data] } }); } catch (_) {}
                            // 内容增量
                            const delta = parsed.delta || '';
                            if (delta) { aiMsgObj.content += delta; updateLastAssistantMessage(aiMsgObj.content); }
                            // 思考过程
                            const rDelta = parsed.rDelta || '';
                            if (rDelta && (window._reasoningEnabledSend !== false)) {
                                const rStr = String(rDelta);
                                try { window._currentAssistantReasoning = (window._currentAssistantReasoning || '') + rStr; } catch (_) {}
                                try { aiMsgObj.reasoning = (aiMsgObj.reasoning || '') + rStr; } catch (_) {}
                                try { saveConversation(); } catch (_) {}
                                try { scheduleUpsertSavedConversation(); } catch (_) {}
                                updateLastAssistantMessage(aiMsgObj.content);
                            }
                            // 引用增量
                            try {
                                const annDelta = parsed.annDelta;
                                if (Array.isArray(annDelta) && annDelta.length) {
                                    aiMsgObj.citations = Array.isArray(aiMsgObj.citations) ? aiMsgObj.citations : [];
                                    for (const it of annDelta) {
                                        if (it && it.type === 'url_citation' && it.url_citation && it.url_citation.url) {
                                            const url = it.url_citation.url;
                                            const exists = aiMsgObj.citations.some(x => x && x.type === 'url_citation' && x.url_citation && x.url_citation.url === url);
                                            if (!exists) aiMsgObj.citations.push(it);
                                        }
                                    }
                                    updateLastAssistantMessage(aiMsgObj.content);
                                }
                            } catch (_) {}
                            // 尾包引用注释
                            try {
                                const finalMsg = parsed.finalMsg;
                                const ann = finalMsg && Array.isArray(finalMsg.annotations) ? finalMsg.annotations : null;
                                if (ann && ann.length) {
                                    aiMsgObj.citations = (aiMsgObj.citations || []).concat(ann);
                                    updateLastAssistantMessage(aiMsgObj.content);
                                }
                            } catch (_) {}
                        } catch (err) {
                            console.debug('解析流片段失败（可能不是 JSON）：', err);
                        }
                    }
                    if (finished) break;
                }
            }
            // 流结束后进行一次最终的持久写回，避免丢失最后片段
            try { upsertSavedConversationNow(); } catch (e) { /* 忽略上报 */ }
            // 流结束后自动尝试生成会话记忆（改为入队异步执行，避免阻塞主流程）
            try { enqueueAutoSummarizeIfNeeded(); } catch (e) { console.error('自动会话记忆入队失败：', e); }

            // 清理 current controller（请求/流已完成）
            try { window._currentRequestController = null; } catch (_) {}
            // 结束日志事件
            try { window.Logger && chatEvtId && window.Logger.end(chatEvtId, { type: 'chat_done' }); } catch (_) {}
        }

        /**
         * 自动摘要（防抖/去重）
         * 功能：当会话新增消息后，在流结束时触发自动摘要；仅当消息条数较上次摘要更多或此前无摘要时执行
         * 参数：无
         * 返回值：Promise
         */
        // 将自动摘要改为可入队的轻量判断函数（实际摘要由后台 memoryWorker 执行）
        function enqueueAutoSummarizeIfNeeded() {
            try {
                const conversationId = localStorage.getItem('deepseekConversationId');
                if (!conversationId) return;
                let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const idx = saved.findIndex(c => c.id === conversationId);
                if (idx === -1) return;
                const entry = saved[idx];
                const msgCount = currentConversation.length;
                const lastCount = entry.lastSummarizedMessageCount || 0;
                if (entry.summary && msgCount <= lastCount) return;
                const apiKey = (window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey'));
                if (!apiKey) return;
                if (!window.PROMPTS || !window.PROMPTS.SESSION_SUMMARY) return;
                const systemPrompt = window.PROMPTS.SESSION_SUMMARY;
                const userContent = currentConversation.map(m => `${(m.role||'').toUpperCase()}: ${m.content||''}`).join('\\n');
                const modelToUse = (entry && entry.model) ? entry.model : (window.MODEL_NAME || 'minimax/minimax-m2:free');
                const url = (window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');
                const requestBody = { model: modelToUse, messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userContent } ], temperature: 0.2 };
                const payload = { apiKey: apiKey, url: url, requestBody: requestBody, msgCount: msgCount, groupId: entry.groupId || null, maxAttempts: 2 };
                enqueueMemoryJob(conversationId, 'session', payload);
            } catch (e) {
                console.error('enqueueAutoSummarizeIfNeeded 失败：', e);
            }
        }

        async function autoSummarizeIfNeeded() {
            const conversationId = localStorage.getItem('deepseekConversationId');
            if (!conversationId) return;
            let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
            const idx = saved.findIndex(c => c.id === conversationId);
            if (idx === -1) return;

            const entry = saved[idx];
            const msgCount = currentConversation.length;
            const lastCount = entry.lastSummarizedMessageCount || 0;
            if (entry.summary && msgCount <= lastCount) return;

            const apiKey = (window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey'));
            if (!apiKey) return;
            if (!window.PROMPTS || !window.PROMPTS.SESSION_SUMMARY) return;

            const systemPrompt = window.PROMPTS.SESSION_SUMMARY;
            const userContent = currentConversation.map(m => `${(m.role||'').toUpperCase()}: ${m.content||''}`).join('\n');

            // 优先使用当前会话记录的模型；若缺失则回退到全局模型
            const modelToUse = (entry && entry.model) ? entry.model : (window.MODEL_NAME || 'minimax/minimax-m2:free');
            const url = (window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');
            // 日志：开始摘要请求
            let _sumEvtId = null;
            try {
                _sumEvtId = (window.Logger && window.Logger.start({
                    type: 'summary_request',
                    endpoint: url,
                    model: modelToUse,
                    req: { headersMasked: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ***masked***' }, body: { model: modelToUse, messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userContent } ], temperature: 0.2 } }
                })) || null;
            } catch (_) {}

            const resp = await fetchWithRetry(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: modelToUse,
                    messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userContent } ],
                    temperature: 0.2
                })
            }, { retries: 2, backoff: 500, timeout: 20000 });
            try { window.Logger && _sumEvtId && window.Logger.append(_sumEvtId, { res: { status: resp.status } }); } catch (_) {}
            if (!resp.ok) { try { window.Logger && _sumEvtId && window.Logger.end(_sumEvtId, { error: { message: '摘要请求失败' } }); } catch (_) {} return; }
            const data = await resp.json();
            const summaryText = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : null;
            try { window.Logger && _sumEvtId && window.Logger.end(_sumEvtId, { type: 'summary_done', res: { final: data } }); } catch (_) {}
            if (!summaryText) return;

            // 更新会话摘要与计数
            saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
            const idx2 = saved.findIndex(c => c.id === conversationId);
            if (idx2 !== -1) {
                saved[idx2].summary = summaryText;
                saved[idx2].lastSummarizedMessageCount = msgCount;
                saved[idx2].updatedAt = new Date().toISOString();
                localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                // 若存在分组，则同步刷新分组记忆
                if (saved[idx2].groupId) {
                    try { await updateGroupMemory(saved[idx2].groupId); } catch (_) {}
                }
            }
        }

        /**
         * 更新分组记忆（index 侧）
         * 功能：聚合指定分组内所有会话的摘要，生成分组级记忆并写回 conversationGroups
         * 参数：groupId - 分组ID
         * 返回值：Promise
         */
        async function updateGroupMemory(groupId) {
            try {
                const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const groupSummaries = saved.filter(c => c.groupId === groupId && c.summary).map(c => c.summary);
                if (groupSummaries.length === 0) return;

                const apiKey = (window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey'));
                if (!apiKey) return;
                if (!window.PROMPTS || !window.PROMPTS.GROUP_SUMMARY) return;

                const systemPrompt = window.PROMPTS.GROUP_SUMMARY;
                const modelToUse = window.MODEL_NAME || 'minimax/minimax-m2:free';
                const url = (window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');
                // 日志：开始分组记忆请求
                let _gmEvtId = null;
                try {
                    _gmEvtId = (window.Logger && window.Logger.start({
                        type: 'groupmem_request',
                        endpoint: url,
                        model: modelToUse,
                        req: { headersMasked: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ***masked***' }, body: { model: modelToUse, messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: groupSummaries.join('\n\n') } ], temperature: 0.2 } }
                    })) || null;
                } catch (_) {}

                const resp = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({
                        model: modelToUse,
                        messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: groupSummaries.join('\n\n') } ],
                        temperature: 0.2
                    })
                }, { retries: 2, backoff: 500, timeout: 20000 });
                try { window.Logger && _gmEvtId && window.Logger.append(_gmEvtId, { res: { status: resp.status } }); } catch (_) {}
                if (!resp.ok) { try { window.Logger && _gmEvtId && window.Logger.end(_gmEvtId, { error: { message: '分组记忆请求失败' } }); } catch (_) {} return; }
                const data = await resp.json();
                const memoryText = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : null;
                try { window.Logger && _gmEvtId && window.Logger.end(_gmEvtId, { type: 'groupmem_done', res: { final: data } }); } catch (_) {}
                if (!memoryText) return;

                let groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                const gi = groups.findIndex(g => g.id === groupId);
                if (gi !== -1) {
                    groups[gi].memorySummary = memoryText;
                    groups[gi].updatedAt = new Date().toISOString();
                    localStorage.setItem('conversationGroups', JSON.stringify(groups));
                }
            } catch (e) {
                console.error('updateGroupMemory 失败：', e);
            }
        }

        /**
         * 更新最后一条助手消息
         * 功能：实时更新页面上最后一条AI消息的内容，重新渲染Markdown并更新操作按钮，同时保存会话到localStorage
         * 参数：content - 要更新的消息内容
         * 返回值：无
         */
        // 将对最后一条助手消息的更新合并到下一帧，减少流式高频 DOM 操作
        window._pendingAssistantUpdate = null;
        window._pendingAssistantUpdateScheduled = false;
        function doUpdateLastAssistantMessage(content) {
            // 优先查找便签纸模式下的最后一条AI回复
            const stickyCards = messageContainer.querySelectorAll('.sticky-note-card');
            let last = null;

            if (stickyCards && stickyCards.length > 0) {
                // 便签纸模式：找到最后一张便签的 .sticky-answer
                const lastCard = stickyCards[stickyCards.length - 1];
                last = lastCard.querySelector('.sticky-answer');
            } else {
                // 传统模式：查找 .message.ai-message
                const nodes = messageContainer.querySelectorAll('.message.ai-message');
                last = nodes && nodes.length ? nodes[nodes.length - 1] : null;
            }

            if (!last) {
                // 如果找不到最后一条消息，可能是渲染还未完成，静默返回不重新渲染
                console.warn('doUpdateLastAssistantMessage: 未找到最后一条AI消息元素');
                return;
            }
            try {
                const rawHtml = (window.marked ? marked.parse(content || '') : (content || ''));
                last.innerHTML = (window.DOMPurify ? DOMPurify.sanitize(rawHtml) : rawHtml);
            } catch (e) {
                last.textContent = content;
            }

            const existingActions = last.querySelector('.message-actions');
            if (existingActions) existingActions.remove();

            // 若已存在思考过程容器，移除以避免重复追加
            const existingReasoning = last.querySelector('.reasoning-block');
            if (existingReasoning) existingReasoning.remove();
            // 若已存在引用容器，移除以避免重复追加
            const existingCitations = last.querySelector('.citations');
            if (existingCitations) existingCitations.remove();

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';

            // 在更新最后一条助手消息时，查找该消息对象的 model 字段用于显示（回退到全局 MODEL_NAME）
            try {
                let lastAssistantIndexTemp = -1;
                for (let i = currentConversation.length - 1; i >= 0; i--) {
                    if (currentConversation[i] && currentConversation[i].role === 'assistant') { lastAssistantIndexTemp = i; break; }
                }
                if (lastAssistantIndexTemp !== -1) {
                    const m = currentConversation[lastAssistantIndexTemp];
                    const modelLabel = document.createElement('div');
                    modelLabel.className = 'message-model';
                    modelLabel.textContent = (m && m.model) ? m.model : (window.MODEL_NAME || 'minimax/minimax-m2:free');
                    actionsDiv.appendChild(modelLabel);
                }
            } catch (_) {}

            const copyBtn = document.createElement('button');
            copyBtn.className = 'action-btn';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                copyToClipboard(content);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'action-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // 计算当前会话中最后一个 assistant 消息的索引并删除，避免依赖外部闭包变量导致引用错误
                let lastAssistantIndex = -1;
                for (let i = currentConversation.length - 1; i >= 0; i--) {
                    if (currentConversation[i] && currentConversation[i].role === 'assistant') {
                        lastAssistantIndex = i;
                        break;
                    }
                }
                if (lastAssistantIndex !== -1) deleteMessage(lastAssistantIndex);
            });

            actionsDiv.appendChild(copyBtn);
            actionsDiv.appendChild(deleteBtn);
            last.appendChild(actionsDiv);
            // 将实时更新的 assistant 内容保存到 localStorage，防止在生成过程中页面刷新/跳转导致内容丢失
            try { saveConversation(); } catch (e) { console.error('保存会话失败：', e); }
            // 节流写回持久会话
            try { scheduleUpsertSavedConversation(); } catch (e) { /* 忽略上报 */ }

            // 渲染思考过程（仅当存在思考内容时显示，默认展开，置于正文前）
            try {
                const rText = (window._currentAssistantReasoning || '').trim();
                const showReasoning = (window._reasoningEnabledSend !== false);
                if (rText && showReasoning) {
                    const reasoningBlock = document.createElement('div');
                    reasoningBlock.className = 'reasoning-block';

                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'reasoning-toggle';
                    const collapsed = !!window._reasoningCollapsed;
                    toggleBtn.textContent = collapsed ? '展开思考过程' : '收起思考过程';

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'reasoning-content';
                    try {
                        const rHtml = (window.marked ? marked.parse(rText) : rText);
                        contentDiv.innerHTML = (window.DOMPurify ? DOMPurify.sanitize(rHtml) : rHtml);
                    } catch (_) {
                        contentDiv.textContent = rText;
                    }
                    contentDiv.style.display = collapsed ? 'none' : 'block';

                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const willShow = (contentDiv.style.display === 'none');
                        contentDiv.style.display = willShow ? 'block' : 'none';
                        window._reasoningCollapsed = !willShow;
                        toggleBtn.textContent = willShow ? '收起思考过程' : '展开思考过程';
                    });

                    reasoningBlock.appendChild(toggleBtn);
                    reasoningBlock.appendChild(contentDiv);
                    // 插入到消息内容最前面（位于正文之前）
                    last.insertBefore(reasoningBlock, last.firstChild);
                }
            } catch (_) { /* 忽略思考过程渲染异常 */ }
            // 已移除页面底部的独立“参考来源”结构化追加，改为仅在消息内渲染或由模型正文提供，避免重复展示和滚动冲突。
            scrollToBottom();
        }

        // 重复的函数定义已删除，使用上面的 doUpdateLastAssistantMessage 函数

        function updateLastAssistantMessage(content) {
            // 合并到下一帧执行，防止流式高频更新触发多次重绘
            window._pendingAssistantUpdate = String(content || '');
            if (window._pendingAssistantUpdateScheduled) return;
            window._pendingAssistantUpdateScheduled = true;
            requestAnimationFrame(() => {
                try {
                    doUpdateLastAssistantMessage(window._pendingAssistantUpdate || '');
                } catch (e) { console.error('更新最后一条助手消息失败：', e); }
                window._pendingAssistantUpdateScheduled = false;
                window._pendingAssistantUpdate = null;
            });
        }

        /**
         * 提取 URL 的域名
         * 功能：用于将引用以域名作为链接文本
         */
        function extractDomain(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace(/^www\./, '');
            } catch (_) {
                const m = String(url || '').match(/^https?:\/\/([^\/]+)/i);
                return m ? m[1] : '';
            }
        }

        /**
         * 根据消息对象构建引用 DOM（去重并返回元素）
         * 参数：anns - 引用数组（包含 url_citation）
         * 返回：DOM element 或 null
         */
        function buildCitationsElement(anns) {
            try {
                if (!Array.isArray(anns) || anns.length === 0) return null;
                // 按 url 去重
                const seen = new Set();
                const uniq = [];
                for (const a of anns) {
                    try {
                        const url = a && a.url_citation && a.url_citation.url;
                        if (!url) continue;
                        if (seen.has(url)) continue;
                        seen.add(url);
                        uniq.push(a);
                    } catch (_) {}
                }
                if (!uniq.length) return null;
                const citeBlock = document.createElement('div');
                citeBlock.className = 'citations citations-collapsed';

                // header with toggle button (默认折叠)
                const header = document.createElement('div');
                header.className = 'citations-header';
                const toggleBtn = document.createElement('button');
                toggleBtn.type = 'button';
                toggleBtn.className = 'citations-toggle';
                toggleBtn.setAttribute('aria-expanded', 'false');
                toggleBtn.textContent = `参考来源 (${uniq.length})`;
                header.appendChild(toggleBtn);

                const list = document.createElement('ol');
                list.className = 'citations-list';
                list.style.paddingLeft = '18px';
                list.style.display = 'none'; // 默认折叠

                for (let idx = 0; idx < uniq.length; idx++) {
                    const a = uniq[idx];
                    const url = a.url_citation.url;
                    const displayTitle = (a.url_citation.title && a.url_citation.title.trim()) ? a.url_citation.title.trim() : (extractDomain(url) || url);
                    const li = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = url;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.textContent = `${displayTitle} — ${url}`;
                    li.appendChild(link);
                    list.appendChild(li);
                }

                // toggle behavior
                try {
                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isCollapsed = list.style.display === 'none';
                        list.style.display = isCollapsed ? 'block' : 'none';
                        toggleBtn.setAttribute('aria-expanded', isCollapsed ? 'true' : 'false');
                    });
                } catch (_) {}

                citeBlock.appendChild(header);
                citeBlock.appendChild(list);
                return citeBlock;
            } catch (e) {
                return null;
            }
        }

        /**
         * 调整 CSS 变量 --session-title-height 为当前标题栏高度，确保聊天容器预留正确高度
         */
        function adjustSessionTitleHeight() {
            try {
                const el = document.getElementById('sessionTitleBar');
                if (!el) return;
                // 读取实际高度（包括 margin? 使用 offsetHeight）
                const h = el.offsetHeight || 0;
                document.documentElement.style.setProperty('--session-title-height', `${h}px`);
                // 触发 chat-container padding-top 重新计算（样式已基于变量）
                try {
                    const chat = document.querySelector('.chat-container');
                    if (chat) chat.style.paddingTop = `${h}px`;
                } catch (_) {}
            } catch (_) {}
        }

        /**
         * 网络请求：带超时与重试的 fetch 封装（不适用于流式 SSE，适用于短请求/摘要/聚合）
         * opts: { retries, backoff, timeout }
         */
        async function fetchWithRetry(url, options = {}, opts = {}) {
            const retries = Number.isFinite(Number(opts.retries)) ? Number(opts.retries) : 2;
            const backoff = Number.isFinite(Number(opts.backoff)) ? Number(opts.backoff) : 400;
            const timeout = Number.isFinite(Number(opts.timeout)) ? Number(opts.timeout) : 15000;
            let attempt = 0;
            while (true) {
                attempt++;
                const controller = new AbortController();
                const timer = setTimeout(() => controller.abort(), timeout);
                try {
                    const merged = Object.assign({}, options, { signal: controller.signal });
                    const resp = await fetch(url, merged);
                    clearTimeout(timer);
                    if (!resp.ok) {
                        const txt = await resp.text().catch(() => '');
                        const err = new Error(`HTTP ${resp.status} ${resp.statusText} ${txt}`);
                        if (attempt > retries) throw err;
                        await new Promise(r => setTimeout(r, backoff * attempt));
                        continue;
                    }
                    return resp;
                } catch (err) {
                    clearTimeout(timer);
                    if (err && err.name === 'AbortError') {
                        // 超时或手动中止
                        if (attempt > retries) throw err;
                        await new Promise(r => setTimeout(r, backoff * attempt));
                        continue;
                    }
                    if (attempt > retries) throw err;
                    await new Promise(r => setTimeout(r, backoff * attempt));
                }
            }
        }

        // 性能采样器：在移动设备上周期性记录时间/内存以便离线分析（用于 chrome://inspect 无法实时连接时）
        window._perfSampler = window._perfSampler || { timer: null, samples: [] };
        function startPerfSampler(intervalMs = 500) {
            try {
                if (window._perfSampler.timer) return;
                window._perfSampler.samples = [];
                window._perfSampler.timer = setInterval(() => {
                    try {
                        const now = Date.now();
                        const perfNow = (typeof performance !== 'undefined' && performance.now) ? performance.now() : null;
                        const mem = (performance && performance.memory) ? { usedJSHeapSize: performance.memory.usedJSHeapSize, totalJSHeapSize: performance.memory.totalJSHeapSize } : null;
                        window._perfSampler.samples.push({ ts: now, perfNow, mem });
                        // 保持样本数量上限，避免占用过多内存
                        if (window._perfSampler.samples.length > 2000) window._perfSampler.samples.shift();
                    } catch (_) {}
                }, Math.max(100, intervalMs));
            } catch (e) { console.error('startPerfSampler 失败：', e); }
        }
        function stopPerfSampler() {
            try {
                if (window._perfSampler && window._perfSampler.timer) {
                    clearInterval(window._perfSampler.timer);
                    window._perfSampler.timer = null;
                }
            } catch (e) { console.error('stopPerfSampler 失败：', e); }
        }

        /**
         * 复制到剪贴板
         * 功能：将指定文本复制到系统剪贴板，并显示状态提示
         * 参数：text - 要复制的文本内容
         * 返回值：无
         */
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showStatus('已复制到剪贴板');
                setTimeout(hideStatus, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
                showStatus('复制失败');
                setTimeout(hideStatus, 2000);
            });
        }

        /**
         * 删除消息
         * 功能：从当前会话中删除指定索引的消息，并保存会话
         * 参数：index - 要删除的消息索引
         * 返回值：无
         */
        function deleteMessage(index) {
            currentConversation.splice(index, 1);
            saveConversation(); // 确保在删除后保存对话
            renderMessages();
        }

        /**
         * 显示状态提示
         * 功能：在状态指示器中显示文本提示，可选择是否显示加载动画
         * 参数：text - 要显示的文本，isLoading - 是否显示加载动画，默认为false
         * 返回值：无
         */
        let statusHideTimer = null;
        function showStatus(text, isLoading = false) {
            try {
                if (statusIndicator) {
                    statusIndicator.textContent = text || '';
                }
                if (statusBarEl && statusBarText) {
                    statusBarText.textContent = text || '';
                    statusBarEl.classList.add('active');
                    const icon = statusBarEl.querySelector('i');
                    if (icon) {
                        icon.classList.toggle('fa-spin', !!isLoading);
                        icon.classList.toggle('fa-circle-notch', !!isLoading);
                        icon.classList.toggle('fa-check', !isLoading);
                    }
                }
                if (statusHideTimer) clearTimeout(statusHideTimer);
                statusHideTimer = setTimeout(() => {
                    if (!isLoading) hideStatus();
                }, isLoading ? 4000 : 2200);
            } catch (e) {
                console.error('showStatus 异常：', e);
            }
        }

        /**
         * 隐藏状态提示
         * 功能：清空状态指示器的内容
         * 参数：无
         * 返回值：无
         */
        function hideStatus() {
            try {
                if (statusIndicator) statusIndicator.textContent = '';
                if (statusBarEl) statusBarEl.classList.remove('active');
                if (statusHideTimer) {
                    clearTimeout(statusHideTimer);
                    statusHideTimer = null;
                }
            } catch (e) {
                console.error('hideStatus 异常：', e);
            }
        }

        /**
         * 滚动到底部
         * 功能：将消息容器滚动到最底部，显示最新消息
         * 参数：无
         * 返回值：无
         */
        function scrollToBottom() {
            try {
                if (!messageContainer) return;
                // 优先滚动到最后一个消息元素，scrollIntoView 更稳健（处理 margin/padding/布局）
                const lastMsg = messageContainer.querySelector('.message:last-child, .ai-message:last-child, .user-message:last-child');
                if (lastMsg && typeof lastMsg.scrollIntoView === 'function') {
                    // 在下一帧执行以确保 DOM 已经更新并已布局
                    requestAnimationFrame(() => {
                        try {
                            lastMsg.scrollIntoView({ behavior: 'auto', block: 'end' });
                        } catch (_) {
                            try { messageContainer.scrollTop = messageContainer.scrollHeight; } catch (_) {}
                        }
                    });
                } else {
                    // 回退：直接设置 scrollTop
                    requestAnimationFrame(() => {
                        try { messageContainer.scrollTop = messageContainer.scrollHeight; } catch (_) {}
                    });
                }
            } catch (e) {
                console.error('scrollToBottom 异常：', e);
            }
        }

        // 欢迎区建议卡一键填充
        (function initSuggestions() {
            try {
                const hero = document.getElementById('welcomeHero');
                if (!hero) return;
                hero.addEventListener('click', (e) => {
                    const t = e.target;
                    if (t && t.classList && t.classList.contains('suggest')) {
                        const text = t.getAttribute('data-text') || '';
                        if (text && messageInput) {
                            messageInput.value = text;
                            try { messageInput.focus(); } catch (_) {}
                            closeDrawer();
                        }
                    }
                });
            } catch (_) {}
        })();

        // 新建会话分组选择模态（迁移自会话管理页）
        function openNewChatGroupModal() {
            const modal = document.getElementById('newChatGroupModal');
            const groupInput = document.getElementById('newGroupNameInput');
            const existingSelect = document.getElementById('existingGroupSelect');
            const nameInput = document.getElementById('newChatNameInput');
            if (!modal || !groupInput || !nameInput) return;
            // 填充已有分组下拉并根据选择显示/隐藏新建分组输入框
            try { populateExistingGroupSelect(); } catch (_) {}
            if (existingSelect) {
                existingSelect.value = '';
                groupInput.style.display = 'block';
            }
            groupInput.value = '';
            nameInput.value = '';
            modal.style.display = 'flex';
        }
        function closeNewChatGroupModal() {
            const modal = document.getElementById('newChatGroupModal');
            if (modal) modal.style.display = 'none';
        }
        (function bindNewChatModal(){
            // 填充模态中的模型下拉（使用 config 页面缓存的模型列表或回退值）
            function populateNewChatModelSelect() {
                try {
                    const sel = document.getElementById('newChatModelSelect');
                    if (!sel) return;
                    sel.innerHTML = '';
                    // 先尝试从 config 页面缓存读取模型列表
                    const cached = JSON.parse(localStorage.getItem('openrouter.models.cache') || 'null');
                    const models = Array.isArray(cached && cached.models) ? cached.models : [];
                    if (models.length) {
                        // models 可能为字符串或对象 {value,label}
                        const placeholder = document.createElement('option');
                        placeholder.value = '';
                        placeholder.textContent = '（使用全局模型）';
                        sel.appendChild(placeholder);
                        for (const m of models) {
                            const opt = document.createElement('option');
                            if (typeof m === 'string') {
                                opt.value = m; opt.textContent = m;
                            } else if (m && typeof m === 'object') {
                                opt.value = m.value || ''; opt.textContent = m.label || m.value || '';
                            }
                            sel.appendChild(opt);
                        }
                    } else {
                        // 无缓存时仅展示当前全局模型作为占位
                        const gm = localStorage.getItem('chatModel') || window.MODEL_NAME || 'minimax/minimax-m2:free';
                        const opt = document.createElement('option');
                        opt.value = ''; opt.textContent = `使用全局模型（${gm}）`;
                        sel.appendChild(opt);
                    }
                    // 尝试默认选中 localStorage.chatModel
                    const savedModel = localStorage.getItem('chatModel') || window.MODEL_NAME || '';
                    if (savedModel) {
                        try { sel.value = savedModel; } catch (_) {}
                    }
                } catch (e) { console.warn('populateNewChatModelSelect failed', e); }
            }

            // 填充分组选择下拉（若无分组则保持显示新建输入框）
            function populateExistingGroupSelect() {
                try {
                    const sel = document.getElementById('existingGroupSelect');
                    const groupInput = document.getElementById('newGroupNameInput');
                    if (!sel) return;
                    sel.innerHTML = '';
                    const placeholder = document.createElement('option');
                    placeholder.value = '';
                    placeholder.textContent = '（创建新分组）';
                    sel.appendChild(placeholder);
                    const groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                    if (Array.isArray(groups) && groups.length) {
                        for (const g of groups) {
                            const opt = document.createElement('option');
                            opt.value = g.id;
                            opt.textContent = g.name;
                            sel.appendChild(opt);
                        }
                    }
                    // 变更时控制新分组输入框显隐
                    sel.addEventListener('change', () => {
                        try {
                            if (!groupInput) return;
                            if (sel.value && sel.value !== '') groupInput.style.display = 'none';
                            else groupInput.style.display = 'block';
                        } catch (_) {}
                    });
                } catch (e) { console.warn('populateExistingGroupSelect failed', e); }
                try { window.populateExistingGroupSelect = populateExistingGroupSelect; } catch (_) {}
            }

            document.addEventListener('DOMContentLoaded', () => {
                try {
                    // 页面就绪时填充模型下拉
                    populateNewChatModelSelect();
                    try { if (typeof populateExistingGroupSelect === 'function') populateExistingGroupSelect(); } catch (_) {}

                    const confirmBtn = document.getElementById('groupModalConfirmBtn');
                    const cancelBtn = document.getElementById('groupModalCancelBtn');
                    if (confirmBtn) confirmBtn.addEventListener('click', () => {
                        const gInput = document.getElementById('newGroupNameInput');
                        const nInput = document.getElementById('newChatNameInput');
                        const modelSel = document.getElementById('newChatModelSelect');
                        const existingSel = document.getElementById('existingGroupSelect');
                        // 读取会话名称（可选），用于保存至 localStorage 以及新建的持久会话条目名称
                        const convName = nInput && nInput.value ? nInput.value.trim() : '';

                        // 优先使用下拉框中已存在的分组：
                        // - 若选择了已有分组，则直接使用对应分组 ID，不再强制要求输入新分组名称；
                        // - 若未选择分组，则仅当“新分组名称”也为空时才提示“请输入分组名称”。
                        let groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                        let target = null;
                        const selectedId = existingSel && existingSel.value ? existingSel.value : '';
                        if (selectedId) {
                            // 根据下拉选择的分组 ID 查找对应分组
                            target = groups.find(g => g && g.id === selectedId) || null;
                        }

                        // 若未选择已有分组，则使用输入的新分组名称（必要时创建新分组）
                        if (!target) {
                            const groupName = gInput && gInput.value ? gInput.value.trim() : '';
                            if (!groupName) { alert('请输入分组名称'); return; }
                            // 查找或创建同名分组（避免重复创建完全相同名称）
                            target = groups.find(g => g && g.name === groupName) || null;
                            if (!target) {
                                target = { id: Date.now().toString(), name: groupName, memorySummary: null, updatedAt: new Date().toISOString() };
                                groups.push(target);
                                localStorage.setItem('conversationGroups', JSON.stringify(groups));
                            }
                        }

                        // 此时 target 一定存在：要么是已选分组，要么是刚创建的新分组
                        localStorage.setItem('deepseekConversationGroupId', target.id);
                        if (convName) localStorage.setItem('deepseekNewConversationName', convName);
                        else localStorage.removeItem('deepseekNewConversationName');

                        // 选择的模型优先级：模态选择 -> 全局 chatModel -> window.MODEL_NAME -> 回退值
                        const selValue = modelSel ? (modelSel.value || '') : '';
                        const selectedModel = selValue || localStorage.getItem('chatModel') || window.MODEL_NAME || 'minimax/minimax-m2:free';
                        // 清空当前临时会话，准备开始新会话
                        // 在开始新会话前，先中止任何正在进行的生成请求并取消待写入，避免旧数据延迟写入覆盖新会话
                        try {
                            if (window._currentRequestController && typeof window._currentRequestController.abort === 'function') {
                                try { window._currentRequestController.abort(); } catch(_) {}
                            }
                            try { window._sendingInProgress = false; } catch(_) {}
                        } catch(_) {}
                        try { if (typeof batchedStorageCancelKey === 'function') batchedStorageCancelKey('deepseekConversation'); } catch(_) {}
                        localStorage.setItem('deepseekConversation', JSON.stringify([]));
                        // 创建并持久化一个空的持久会话条目，使其立即出现在抽屉中
                        try {
                            const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                            const newId = Date.now().toString();
                            const entryName = convName || (document.getElementById('newChatNameInput') && document.getElementById('newChatNameInput').placeholder) || '新会话';
                            const newEntry = {
                                id: newId,
                                name: entryName,
                                messages: [],
                                summary: null,
                                groupId: target.id,
                                model: selectedModel || (window.MODEL_NAME || null),
                                updatedAt: new Date().toISOString(),
                                lastSummarizedMessageCount: 0
                            };
                            saved.push(newEntry);
                            localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                            localStorage.setItem('deepseekConversationId', newId);
                            // 将新建时选择的模型同步为全局模型（使标题栏与配置页即时反映）
                            try {
                                if (selectedModel) {
                                    try { localStorage.setItem('chatModel', selectedModel); } catch(_) {}
                                    try { window.MODEL_NAME = selectedModel; } catch(_) {}
                                    try { updateCurrentModelBadge(); } catch(_) {}
                                }
                            } catch (_) {}
                        } catch (_) {}
                        // 刷新界面与抽屉列表
                        loadConversation(); renderMessages(true); renderWelcomeIfEmpty();
                        try { renderSessionTitle(); } catch (_) {}
                        renderDrawerConversationsList();
                        closeNewChatGroupModal(); closeDrawer();
                    });
                    if (cancelBtn) cancelBtn.addEventListener('click', () => { closeNewChatGroupModal(); });
                } catch (_) {}
            });
        })();

        /**
         * 构建联网结果综合提示
         * 功能：当启用 Web 插件时，要求模型先给出“最终答案”，再附带引用；加强准确性与可读性约束
         */
        function buildWebSynthesisPrompt() {
            try {
                const p = (window.PROMPTS && window.PROMPTS.WEB_SYNTHESIS);
                return (typeof p === 'string') ? p : '';
            } catch (_) {
                return '';
            }
        }
    </script>
    <!-- 新建会话分组选择模态（默认隐藏） -->
    <div id="newChatGroupModal" class="modal-overlay" style="display:none;">
        <div class="modal">
            <h3 class="modal-title">新建会话</h3>
            <p class="modal-desc">请输入分组名称（必填）与会话名称（可选）。如分组不存在将自动创建。</p>
            <select id="existingGroupSelect" class="modal-input" style="width:100%; margin-bottom:6px;"></select>
            <input id="newGroupNameInput" class="modal-input" placeholder="输入分组名称（必填）" maxlength="50" />
            <input id="newChatNameInput" class="modal-input" placeholder="输入会话名称（可选）" maxlength="50" />
            <!-- 新增：选择模型（可选，若不选择则使用全局模型） -->
            <label for="newChatModelSelect" class="modal-label" style="margin-top:6px;">选择模型（可选）：</label>
            <select id="newChatModelSelect" class="modal-input" style="width:100%;"></select>
            <div class="modal-actions">
                <button id="groupModalConfirmBtn">确认</button>
                <button id="groupModalCancelBtn">取消</button>
            </div>
        </div>
    </div>
</body>
</html>
</html>
</html>