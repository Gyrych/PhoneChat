<!-- 8dc79657-9b20-4d27-8e8a-5940ab975ced 4333af3d-9360-4026-927a-cfe4858ee873 -->
# 每条消息展示所属模型（按消息级别）实现计划

**目标**

- 每条 assistant 消息都带有 `model` 字段并在 UI（消息操作按钮同一行）显示该字段，优先使用消息对象上的 `model`，若流式响应包含 provider 返回的模型信息则以响应为准。

**要修改的文件**

- `index.html`（主实现）
- `dist/index.html`（同步构建产物）
- `style.css` / `dist/style.css`（如需微调样式）
- `CURSOR.md` / `README.md` / `README_zh.md`（文档说明同步）

**实现要点（精确）**

1. 在发送前创建 assistant 占位消息时，设置 `aiMsgObj.model = MODEL_NAME`：
```js
const aiMsgObj = { role: 'assistant', content: '', reasoning: '', model: MODEL_NAME };
```

2. 在流式解析过程中，若流片段或最终 JSON 包含模型信息（检查顺序：`json.model` → `json.model_name` → `json.choices?.[0]?.model` → `json.choices?.[0]?.message?.model`），则覆盖 `aiMsgObj.model` 并调用 `updateLastAssistantMessage(aiMsgObj.content)` 以实时反映 UI：
```js
const detectedModel = json.model || json.model_name || (json.choices && json.choices[0] && (json.choices[0].model || (json.choices[0].message && json.choices[0].message.model)));
if (detectedModel) { aiMsgObj.model = detectedModel; updateLastAssistantMessage(aiMsgObj.content); }
```

3. 在渲染/更新最后一条助手消息（`updateLastAssistantMessage` / `renderMessages`）时，使用消息对象的 `message.model` 字段来构建并显示 `.message-model`（已存在但需保证 message 对象保存了该字段）。
4. 当持久化会话（保存到 `localStorage`）或写入 `savedDeepseekConversations` 时，确保每个 assistant 消息对象的 `model` 被保留（通常保存整个 `currentConversation` 即可，因为我们在步骤1/2中已写入该字段）。
5. 文档：在 `CURSOR.md` / README 中加入“按消息记录生成模型”说明（实现原因与回退逻辑）。

**回退与兼容性**

- 若响应未包含模型信息，消息将保留创建时的 `MODEL_NAME`（可靠回退）。
- 局部测试：将修改先应用到 `index.html`，在浏览器控制台验证 `currentConversation` 中 assistant 条目的 `model` 字段随流式响应/完成时更新。

**预计变更量**

- 小范围 JS 修改（~3 处）与少量文档更新；不修改后端接口。

---

如果你同意，我会按以上计划实现并提交改动（先修改 `index.html` / `dist/index.html`，再同步样式与文档），随后运行 linter 并更新 TODO 状态。

### To-dos

- [ ] 实现消息级 model 字段写入与流式覆盖（修改 `index.html` / `dist/index.html`）
- [ ] 更新 `CURSOR.md` / `README.md` / `README_zh.md`：记录消息级 model 展示的行为与回退逻辑