<!-- c016c25d-7b14-4b4f-bb94-51b6a84cbaed 0e157ad2-94bc-460d-b063-b05a559d9974 -->
# 实现：在设置页运行时从 OpenRouter 实时更新模型列表

概述：

- 在 `config.html` 的加载流程中，增加一次对 `https://openrouter.ai/models?fmt=cards&input_modalities=text&max_price=0&output_modalities=text` 的 `fetch` 请求，解析返回 HTML 中的模型标识列表，并用结果替换隐藏的 `<select id="modelSelect">` 的 `<option>`。随后调用现有的 `buildCustomModelSelect()` 以渲染自定义下拉。结果将缓存在 `localStorage` 中（默认 24 小时 TTL），减少请求频率并提升离线可用性。
- 兼容性与回退：若网络请求失败或解析后没有有效模型列表，则保留并使用当前硬编码列表；在控制台与 UI（可选短提示）告知用户更新失败。

关键文件（将被编辑）：

- `config.html`（主要）：在现有内联脚本中添加 `updateModelListFromOpenRouter()`，并在 `DOMContentLoaded` 时优先调用。仍保留原有隐藏的 `#modelSelect` 初始静态项作为回退。 
- `dist/config.html`（同步）：在发布/构建产物中同步相同修改。

核心实现要点与精简代码片段（用于评审，实际实现会嵌入 `config.html` 的内联 <script>）：

1) 拉取 + 缓存 + 简单解析并填充 `select`：

```javascript
async function updateModelListFromOpenRouter() {
  const url = 'https://openrouter.ai/models?fmt=cards&input_modalities=text&max_price=0&output_modalities=text';
  const cacheKey = 'openrouter.models.cache';
  const ttl = 24 * 60 * 60 * 1000; // 24h
  try {
    const cached = JSON.parse(localStorage.getItem(cacheKey) || 'null');
    if (cached && Date.now() - cached.ts < ttl) {
      populateSelect(cached.models);
      return;
    }

    const res = await fetch(url, { credentials: 'omit' });
    const text = await res.text();

    // 从页面文本抽取类似 provider/model(:tag) 的标识
    const found = Array.from(new Set((text.match(/[\w\-.]+\/[\w\-.]+(?::[\w\-.]+)?/g) || [])));
    const models = found.sort();
    if (models.length) {
      localStorage.setItem(cacheKey, JSON.stringify({ ts: Date.now(), models }));
      populateSelect(models);
    } else {
      console.warn('未解析到模型列表，保留本地选项');
    }
  } catch (err) {
    console.warn('更新 OpenRouter 模型列表失败：', err);
  }
}

function populateSelect(models) {
  const select = document.getElementById('modelSelect');
  if (!select) return;
  const placeholder = '<option value="">请选择模型</option>';
  select.innerHTML = placeholder + models.map(m => `<option value="${m}">${m}</option>`).join('');
  // 如已构建自定义下拉，重新构建以应用新选项
  buildCustomModelSelect(select);
}
```

2) 在 `DOMContentLoaded` 中的调用时机：

- 先调用 `updateModelListFromOpenRouter()`；fetch 完成或回退后，调用 `buildCustomModelSelect(document.getElementById('modelSelect'))`（上面 `populateSelect` 会在成功时直接调用），以保证自定义下拉使用最新的选项。仍保留读取并显示 `localStorage.chatModel` 的逻辑。

3) UX 与错误处理：

- 若 fetch 被 CORS/网络阻断，脚本会在控制台输出警告并继续使用页面内硬编码的选项；可在页面 `#saveMessage` 或在 `custom-select` 面板上短暂显示“模型列表更新失败，使用本地列表”的提示（可选）。

4) 安全与性能注意：

- 解析采用简单正则（如上）以避免依赖远端页面 DOM 结构脆弱性；若后期需更稳健解析，可在服务器端提供清洁 JSON 列表或基于 OpenRouter API 的官方接口（若可用）。
- 默认缓存 24 小时，可通过 localStorage 键覆盖（例如 `openrouter.models.ttlMs`），或将 TTL 暴露为常量以便测试/调整。

测试与验收准则（Manual/快速验收）：

- 打开 `config.html`，脚本应在加载时尝试从 OpenRouter 拉取并在自定义下拉中展示最新模型名称；若成功，`modelSelect` 的 `<option>` 数量应反映拉取到的模型；若失败，应看到控制台警告且页面仍可用（使用硬编码选项）。

实现任务（todos）：

- id: fetch-and-parse  content: 在 `config.html` 中实现 `updateModelListFromOpenRouter()`（拉取、解析、缓存、填充 select）。
- id: ui-and-error-handling  content: 增加简短的 UI 提示（失败/更新成功），并保证在失败时不破坏现有本地保存/自定义下拉行为。
- id: sync-dist  content: 将相同改动同步到 `dist/config.html`（构建/发布产物）。

备注：我将先按此计划实现变更；若你确认，我会开始实际编码（在开始前我会再次列出将要变更的确切代码段和文件行号以供你确认）。

### To-dos

- [ ] 在 `config.html` 中实现 `updateModelListFromOpenRouter()`（拉取、解析、缓存、填充 select）。
- [ ] 增加短暂 UI 提示（更新成功/失败），并确保失败时回退到本地硬编码列表。
- [ ] 将同样的更改同步到 `dist/config.html`（构建/发布产物）。