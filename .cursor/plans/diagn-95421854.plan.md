<!-- 95421854-fa08-467a-bbe4-ce2a2f964e76 124c6ff1-3259-465d-a5ce-462c6f8917c2 -->
# 性能排查与优化计划（FreeChat）

简述：本计划针对你反馈的“与大模型对话卡顿”和“移动端 APP 卡顿并闪退”问题，优先按低侵入、可回退的顺序进行诊断与优化：先收集运行时证据（网络时延 / 流式延迟 / localStorage 写入频率 / 内存增长），再做可验证的前端优化（AbortController、流式渲染合并、批量写入、懒加载、限制记忆注入、减少昂贵 CSS），最后若仍未解决，考虑将重负载移到 Web Worker 或后端代理。

关键要检查的文件与位置：

- `index.html` / `dist/index.html`（流式解析与渲染、localStorage 写入点、记忆注入）
- `logger.js` / `dist/logger.js`（收集网络时延、durationMs 字段）
- `style.css` / `dist/style.css`（移动端 `backdrop-filter`/重排样式）
- `scripts/build.js`（构建到 `dist/` 的流程）
- `capacitor.config.json`（`webDir: "dist"`，确认 Capacitor 使用 `dist`）
- `package.json`（已确认 `build` 脚本为 `node scripts/build.js`）

步骤（可执行、可回退）：

1. 证据收集（优先）

- 导出 `localStorage.freechat.logs`（在 `index.html` 的导出日志按钮或控制台调用 `Logger.export({ scope: 'current' })`），获取多轮请求的 `durationMs`、`res.streamChunks`、`error` 信息。
- 在手机 WebView 上使用 Chrome 远程调试（chrome://inspect）捕获 Performance trace + Network timings + Heap snapshot 在对话过程中（关注大模型请求的等待时间与流式增量处理消耗时间）。
- 重现导致闪退的场景并记录设备型号/Android 版本、WebView 版本、复现步骤（消息内容长度、是否启用联网检索/记忆注入）。

2. 快速可回退修复（低侵入）

- 在 `index.html` 引入 `AbortController` 支持，点击“停止生成”应真正调用 `controller.abort()` 并清理流读循环。引用文件：`index.html`（流式函数 `fetchDeepSeekResponseStream`）。
- 合并流式渲染：把流式增量的 DOM 更新节流/合并到下一帧（使用 `requestAnimationFrame`），减少重绘频率（修改点：`updateLastAssistantMessage` 调度）。
- 批量写入 localStorage：实现 `batchedStorageSetJson(key, obj, delay=400)`，把频繁写入合并以降低同步 I/O（影响：显著降低 CPU 与主线程阻塞）。
- 懒加载 `marked` 与 `DOMPurify`（在需要第一次渲染 Markdown 时动态 import），减少首屏阻塞。
- 在记忆注入处限制注入条数或总字符（例如最多注入 3 条分组记忆 + 3 条会话记忆，且每条截断到 1000 字符），以减少请求体大小与模型处理时间。

3. 中度优化（若卡顿仍明显）

- 将流解析/增量合并逻辑移到 Web Worker（解析 JSON、聚合文本），主线程仅做最小 DOM 更新（避免主线程被文本解析阻塞）。
- 对消息列表进行虚拟化（仅渲染可视区消息），避免大量消息 DOM 节点在移动端造成内存与布局压力。
- 移除或替换移动端昂贵 CSS（如 `backdrop-filter`）为性能更好的替代，以减少合成层和 GPU/内存占用。

4. 网络/模型层面的策略

- 如果 API 请求本身延时大：显示更友好的流式占位并在日志中记录远端延迟，考虑在服务端做代理并在代理处合并/裁剪上下文，或使用更小模型作“摘要层”降低上下游请求成本。
- 对于联网检索（Web Search），增加短期节流与更强的 debounce，避免用户短时间内触发多次高成本检索。

5. 验证与回归测试

- 每项变更均使用 Chrome DevTools Performance trace 与 Memory snapshot 做回归：记录变更前后 CPU 着色/帧率/GC 次数与堆占用。
- 在真机（问题机型）上用 Capacitor 打包并运行测试用例，确认闪退是否消失并观察内存/CPU趋势。

6. 文档与变更记录

- 所有变更在 `CURSOR.md` 与 `README_zh.md`/`README.md` 中同步记录变更理由与回退方法（符合你之前设定的文档要求）。

实现 Todos（原子、可跟踪）：

- id: confirm-build-dir
content: 确认构建目录与构建脚本（检查 `scripts/build.js` 与 `package.json` 配置）
- id: collect-runtime-logs
content: 导出并分析 `localStorage.freechat.logs` 中的网络与流式延迟记录
- id: remote-debug-mobile
content: 在目标手机 WebView 上通过 chrome://inspect 采集 Performance trace 与 Heap snapshot
- id: add-abortcontroller
content: 在 `fetchDeepSeekResponseStream` 中引入 `AbortController` 并使“停止生成”真正中止请求
- id: batch-localstorage-writes
content: 实现 `batchedStorageSetJson`（默认 400ms 合并）以减少 localStorage 写入频率
- id: rAF-merge-stream-updates
content: 将流式增量渲染合并到 `requestAnimationFrame`，降低重绘频率
- id: lazy-load-marked-dompurify
content: 实现动态导入 `marked`/`DOMPurify`，减少首屏阻塞
- id: limit-memory-injection
content: 在构建请求体前限制注入的记忆条数与每条最大字符数（可配置）
- id: workerize-stream-parser
content: 若主线程仍卡顿，将流式解析/增量拼接移到 Web Worker 并在主线程只更新最小 DOM
- id: virtualize-message-list
content: 对消息列表实现虚拟化（仅渲染可见区）以降低移动端 DOM 数量
- id: perf-validate-on-device
content: 打包 APK（`npm run build && npx cap copy && npx cap open android`）并在问题机上做回归验证

请确认是否按此计划执行（我会在你确认后把计划写入系统并开始逐项操作与实现具体修改）。

### To-dos

- [ ] 确认构建目录与构建脚本（检查 `scripts/build.js` 与 `package.json` 配置
- [ ] 导出并分析 `localStorage.freechat.logs` 中的网络与流式延迟记录
- [ ] 在目标手机 WebView 上通过 chrome://inspect 采集 Performance trace 与 Heap snapshot
- [ ] 在 `fetchDeepSeekResponseStream` 中引入 `AbortController` 并使“停止生成”真正中止请求
- [ ] 实现 `batchedStorageSetJson`（默认 400ms 合并）以减少 localStorage 写入频率
- [ ] 将流式增量渲染合并到 `requestAnimationFrame`，降低重绘频率
- [ ] 实现动态导入 `marked`/`DOMPurify`，减少首屏阻塞
- [ ] 在构建请求体前限制注入的记忆条数与每条最大字符数（可配置）
- [ ] 若主线程仍卡顿，将流式解析/增量拼接移到 Web Worker 并在主线程只更新最小 DOM
- [ ] 对消息列表实现虚拟化（仅渲染可见区）以降低移动端 DOM 数量
- [ ] 打包 APK 并在问题机上做回归验证以确认闪退与卡顿是否解决