<!-- 98ad0c84-d5f9-4e67-8d3d-cd7f40ce7ac8 755ea22a-cff7-41ba-98c2-294306b44a14 -->
# 修复：会话模型在主页面未正确同步为发送模型

## 问题描述

用户在抽屉（侧边栏）中新建会话并选择了模型，但进入会话后发送请求仍使用旧的/脚本初始化时的模型，导致模型未随会话切换。

## 根因分析（已验证）

- 在 `index.html` 顶部，脚本初始化时用 `const MODEL_NAME = localStorage.getItem('chatModel') || 'minimax/minimax-m2:free';` 固定了 `MODEL_NAME` 常量。随后某些路径（例如从抽屉加载已保存会话）会更新 `localStorage.chatModel` 或 `window.MODEL_NAME`，但 `MODEL_NAME` 常量不会改变。
- 发送请求的代码（构建 requestBody、判断 provider、supportsMultiSystem 等处）仍使用 `MODEL_NAME` 常量，导致发送时使用的是初始化时的值而不是当前会话的模型。

## 修复方案（建议）

- 在 `index.html` 中新增一个轻量的运行时访问函数：
```javascript
function getCurrentModel() {
  return localStorage.getItem('chatModel') || window.MODEL_NAME || 'minimax/minimax-m2:free';
}
```

- 将发送流程中对 `MODEL_NAME` 的直接引用替换为 `getCurrentModel()`：包括但不限于：
  - 构建 `requestBody.model` 的位置
  - 传给 `inferProviderFromModel()` 的参数
  - `supportsMultiSystem()` 的参数
  - 日志/事件记录中记录的 model 字段
  - 创建 assistant 占位消息（`aiMsgObj.model`）可改为 `getCurrentModel()`，以保证消息元信息一致

- 保持 `window.MODEL_NAME` 的写入（已有代码在新建/加载会话处会写 `window.MODEL_NAME = selectedModel`），以向后兼容但不再依赖脚本级常量。

- 同步更新打包产物 `dist/index.html`（如果项目使用 `dist/` 发布，需要同步修改）以及必要时的 `conversations.html` 中有关发送/摘要的 model 使用处。

- 按用户要求，修改后同时更新 `CURSOR.md` 与 `README.md`/`README_zh.md` 的相应说明（短语说明为何改动：避免常量缓存导致模型不同步）。

## 验收标准

- 在抽屉中新建会话并选择非默认模型 → 打开会话 → 发送消息时，网络请求中 `model` 字段与抽屉选择一致。
- 从会话列表加载历史会话（包含 `model` 字段）→ 跳转到主页 → 发送消息时使用该会话保存的模型。
- 单元/手工测试通过（在浏览器打开 devtools Network 面板观察请求 body）。

## 变更文件

- `index.html`（主要修改）
- `dist/index.html`（同步修改）
- `conversations.html`（若其中有重复的发送逻辑则同步）
- 文档：`CURSOR.md`、`README.md`、`README_zh.md`

## 风险与回滚

- 风险低：仅将对模型名的读取从静态常量改为运行时读取。回滚只需恢复对 `MODEL_NAME` 常量的使用或删除 `getCurrentModel()` 的替换调用。

## 实施步骤（todos）

- create-helper: 在 `index.html` 添加 `getCurrentModel()` 并确保引用处使用它
- replace-usages: 在发送/日志/推断相关处替换 `MODEL_NAME` 为 `getCurrentModel()`
- dist-sync: 将相同修改应用于 `dist/index.html`（保持发布产物同步）
- docs-update: 更新 `CURSOR.md` 与 `README`（中/英）说明变更原因与位置
- verification: 在浏览器中验证模型字段随会话切换正常生效

请确认我可以按此计划实施修改（我将先在 `index.html` 做最小可行改动并运行本地检查）。如果你偏好另一实现（例如在会话加载时重新初始化 `MODEL_NAME` 常量），请回复选择：

1. 使用运行时读取 `getCurrentModel()`（推荐，兼容且低侵入）
2. 在每次模型更新时尝试重新定义/替换 `MODEL_NAME`（不推荐，因为 `const` 不可重定义，需改为 `let` 并存在潜在作用域影响）

默认我会按选项 1 实施。