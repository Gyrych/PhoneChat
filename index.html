<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FreeChat</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="prompts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="logger.js"></script>
    <style>
        .input-container { position: relative; }
        .stop-btn-floating {
            position: absolute;
            right: 86px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: #e74c3c;
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            padding: 0;
        }
        .stop-btn-floating:active { transform: translateY(-50%) scale(0.96); }
        .stop-btn-floating .fa-stop { font-size: 14px; }
        .stop-btn-floating { touch-action: manipulation; -webkit-user-select: none; user-select: none; }
    </style>
</head>
<body>
    <header class="header">
        <button id="conversationsBtn" class="conversations-btn">
            <i class="fas fa-history"></i>
        </button>
        <div class="brand">
            <h1>FreeChat</h1>
            <span id="currentModelBadge" class="model-badge"></span>
        </div>
        <button id="exportLogsBtn" class="settings-btn" title="导出日志">
            <i class="fas fa-file-export"></i>
        </button>
        <button id="clearLogsBtn" class="settings-btn" title="清空日志">
            <i class="fas fa-trash"></i>
        </button>
        <button id="settingsBtn" class="settings-btn">
            <i class="fas fa-cog"></i>
        </button>
    </header>

    <main class="chat-container">
        <div id="messageContainer" class="message-container"></div>
        <div id="statusIndicator" class="status-indicator"></div>
    </main>

    <footer class="input-container">
        <textarea
            id="messageInput"
            class="message-input"
            placeholder="输入消息...（换行请按Shift+Enter）"
            rows="3"
        ></textarea>
        <button id="sendBtn" class="send-btn">
            <i class="fas fa-paper-plane"></i>
        </button>
        <button id="stopBtn" class="stop-btn-floating" title="停止生成" aria-label="停止生成">
            <i class="fas fa-stop"></i>
        </button>
    </footer>

    <script>
        /**
         * 文件名：index.html
         * 功能描述：FreeChat 主聊天页面，提供聊天界面、消息发送与接收、流式响应显示、会话管理等功能
         */
        document.getElementById('settingsBtn').addEventListener('click', function() {
            window.location.assign('config.html');
        });

        document.getElementById('conversationsBtn').addEventListener('click', function() {
            window.location.assign('conversations.html');
        });

        let currentConversation = [];
        let currentConversationGroupId = null;
        window.DEEPSEEK_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
        const MODEL_NAME = localStorage.getItem('chatModel') || 'minimax/minimax-m2:free';
        window.MODEL_NAME = MODEL_NAME;

        const LOCAL_PASSPHRASE = 'local_obfuscation_passphrase_2025';
        const ENCRYPTED_OPENROUTER_KEY = 'U2FsdGVkX18PSVwBhdx/XQSmTwr5UimvbPYKhcmoMNXytQwT4HgYIMh2Hl/BxCv/0zYPUjEzfprco76j74BEMQIjYwM5iIkP7VMSS1vKYLqbhNjbCqP369SdZlcmikUg';

        /**
         * 解密API密钥
         * 参数：encryptedBase64 - 加密后的Base64字符串，passphrase - 解密密码
         * 返回值：解密后的API密钥字符串，失败返回null
         */
        function decryptApiKey(encryptedBase64, passphrase) {
            try {
                const bytes = CryptoJS.AES.decrypt(encryptedBase64, passphrase);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                console.error('解密 API Key 失败：', e);
                return null;
            }
        }

        const OPENROUTER_API_KEY = decryptApiKey(ENCRYPTED_OPENROUTER_KEY, LOCAL_PASSPHRASE);
        window.OPENROUTER_API_KEY = OPENROUTER_API_KEY;
        const messageContainer = document.getElementById('messageContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusIndicator = document.getElementById('statusIndicator');

        /**
         * 初始化应用
         * 功能：加载会话数据、渲染消息、绑定事件监听器（发送按钮、输入框、停止按钮等）
         * 参数：无
         * 返回值：无
         */
        function initApp() {
            if (window._appInitialized) return;
            window._appInitialized = true;

            console.log('initApp: attaching handlers');
            try { updateCurrentModelBadge(); } catch (e) { /* 忽略徽标更新异常 */ }
            loadConversation();
            renderMessages();
            if (sendBtn) {
                sendBtn.addEventListener('click', sendMessage);
                sendBtn.onclick = sendMessage;
            } else {
                console.error('sendBtn 未找到');
            }

            if (messageInput) {
                messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }

            stopBtn.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                stopGeneration();
            });

            stopBtn.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: true });

            // 日志导出与清空按钮事件
            try {
                const exportBtn = document.getElementById('exportLogsBtn');
                const clearBtn = document.getElementById('clearLogsBtn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => {
                        // 简单选择导出格式：默认 ndjson
                        const fmt = prompt('选择导出格式：输入 "ndjson" 或 "json"', 'ndjson');
                        const format = (fmt && fmt.toLowerCase() === 'json') ? 'json' : 'ndjson';
                        try { window.Logger && window.Logger.export({ format }); } catch (_) {}
                    });
                }
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        if (confirm('确定要清空所有日志吗？该操作不可恢复。')) {
                            try { window.Logger && window.Logger.clear(); } catch (_) {}
                        }
                    });
                }
            } catch (_) { /* 忽略绑定异常 */ }
        }

        document.addEventListener('DOMContentLoaded', initApp);
        window.addEventListener('load', initApp);

        /**
         * 加载会话
         * 功能：从localStorage加载保存的会话数据和分组ID
         * 参数：无
         * 返回值：无
         */
        function loadConversation() {
            const savedConversation = localStorage.getItem('deepseekConversation');
            if (savedConversation && savedConversation !== 'undefined') {
                try {
                    currentConversation = JSON.parse(savedConversation);
                } catch (err) {
                    console.error('解析 deepseekConversation 失败，已清理该键：', err, savedConversation);
                    currentConversation = [];
                    localStorage.removeItem('deepseekConversation');
                }
            }
            const grp = localStorage.getItem('deepseekConversationGroupId');
            currentConversationGroupId = (grp && grp !== 'undefined' && grp !== 'null') ? grp : null;
            // 加载时尝试同步更新当前模型徽标（若用户从会话管理页恢复了模型）
            try { updateCurrentModelBadge(); } catch (e) { /* 忽略异常 */ }
        }

        /**
         * 设置当前会话分组
         * 功能：更新当前会话所属的分组ID，并保存到localStorage
         * 参数：groupId - 分组ID，为null时表示未分组
         * 返回值：无
         */
        function setCurrentConversationGroup(groupId) {
            currentConversationGroupId = groupId;
            if (groupId) localStorage.setItem('deepseekConversationGroupId', groupId);
            else localStorage.removeItem('deepseekConversationGroupId');
        }

        /**
         * 保存会话
         * 功能：将当前会话数组保存到localStorage
         * 参数：无
         * 返回值：无
         */
        function saveConversation() {
            localStorage.setItem('deepseekConversation', JSON.stringify(currentConversation));
        }

        /**
         * 更新当前模型徽标
         * 功能：将 window.MODEL_NAME 或 localStorage.chatModel 显示在页面头部徽标处
         * 参数：无
         * 返回值：无
         */
        function updateCurrentModelBadge() {
            const badge = document.getElementById('currentModelBadge');
            if (!badge) return;
            const name = (window.MODEL_NAME || localStorage.getItem('chatModel') || '').trim();
            badge.textContent = name || '未选择模型';
        }

        /**
         * 持久会话节流更新
         * 功能：将当前会话内容按节流策略写回 savedDeepseekConversations 对应条目，降低频繁写入
         * 参数：无（内部获取 deepseekConversationId）
         * 返回值：无
         */
        const UPSERT_INTERVAL_MS = 1500;
        let upsertTimer = null;
        function upsertSavedConversationNow() {
            const conversationId = localStorage.getItem('deepseekConversationId');
            if (!conversationId) return;
            try {
                let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const idx = saved.findIndex(c => c.id === conversationId);
                if (idx === -1) return;
                saved[idx].messages = currentConversation.slice();
                saved[idx].updatedAt = new Date().toISOString();
                // 同步保存当前使用的模型，保证会话记录模型可被恢复
                saved[idx].model = window.MODEL_NAME;
                // 保持分组ID与当前内存一致
                saved[idx].groupId = currentConversationGroupId || null;
                localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
            } catch (e) {
                console.error('upsertSavedConversationNow 失败：', e);
            }
        }
        function scheduleUpsertSavedConversation() {
            if (upsertTimer) return;
            upsertTimer = setTimeout(() => {
                upsertTimer = null;
                upsertSavedConversationNow();
            }, UPSERT_INTERVAL_MS);
        }

        /**
         * 渲染消息列表
         * 功能：将当前会话中的所有消息渲染到页面上，AI消息使用Markdown渲染，用户消息显示纯文本，每条消息包含复制和删除按钮
         * 参数：无
         * 返回值：无
         */
        function renderMessages() {
            messageContainer.innerHTML = '';

            currentConversation.forEach((message, index) => {
                const messageElement = document.createElement('div');
                messageElement.className = `message ${message.role === 'user' ? 'user-message' : 'ai-message'}`;
                if (message.role === 'assistant') {
                    try {
                        // 优先渲染思考过程（若有），再渲染正文
                        messageElement.innerHTML = '';
                        const reasoningText = (message.reasoning || '').trim();
                        if (reasoningText) {
                            const reasoningBlock = document.createElement('div');
                            reasoningBlock.className = 'reasoning-block';

                            const toggleBtn = document.createElement('button');
                            toggleBtn.className = 'reasoning-toggle';
                            toggleBtn.textContent = '收起思考过程'; // 默认展开

                            const rDiv = document.createElement('div');
                            rDiv.className = 'reasoning-content';
                            try {
                                const rHtml = marked.parse(reasoningText);
                                rDiv.innerHTML = DOMPurify.sanitize(rHtml);
                            } catch (_) {
                                rDiv.textContent = reasoningText;
                            }
                            rDiv.style.display = 'block';

                            toggleBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const willShow = (rDiv.style.display === 'none');
                                rDiv.style.display = willShow ? 'block' : 'none';
                                toggleBtn.textContent = willShow ? '收起思考过程' : '展开思考过程';
                            });

                            reasoningBlock.appendChild(toggleBtn);
                            reasoningBlock.appendChild(rDiv);
                            messageElement.appendChild(reasoningBlock);
                        }

                        const rawHtml = marked.parse(message.content || '');
                        const cleanHtml = DOMPurify.sanitize(rawHtml);
                        const contentHolder = document.createElement('div');
                        contentHolder.innerHTML = cleanHtml;
                        messageElement.appendChild(contentHolder);
                    } catch (e) {
                        console.error('Markdown 渲染失败，退回纯文本显示：', e);
                        messageElement.textContent = message.content;
                    }
                } else {
                    messageElement.textContent = message.content;
                }

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'action-btn';
                copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                copyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    copyToClipboard(message.content);
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'action-btn';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteMessage(index);
                });

                actionsDiv.appendChild(copyBtn);
                actionsDiv.appendChild(deleteBtn);
                messageElement.appendChild(actionsDiv);

                messageContainer.appendChild(messageElement);
            });

            scrollToBottom();
        }

        /**
         * 发送消息
         * 功能：获取用户输入的消息，添加到会话中，调用API获取AI响应，实时更新界面
         * 参数：无
         * 返回值：Promise，无返回值
         */
        async function sendMessage() {
            console.log('sendMessage invoked');
            try {
                // 在发送期间禁用发送按钮，防止用户重复触发并发发送
                if (sendBtn) sendBtn.disabled = true;
                const messageText = messageInput.value.trim();
                console.log('messageText length:', messageText.length);
                if (!messageText) return;

                const apiKey = OPENROUTER_API_KEY;
                console.log('using built-in OPENROUTER_API_KEY present:', !!apiKey);
                if (!apiKey) {
                    showStatus('内置 API Key 未配置，无法发送请求');
                    return;
                }

                currentConversation.push({ role: 'user', content: messageText });
                messageInput.value = '';
                saveConversation();

                // 若这是当前页面内首次发送（尚无持久会话ID），则自动创建持久会话条目
                try {
                    const existingId = localStorage.getItem('deepseekConversationId');
                    if (!existingId) {
                        const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                        const newId = Date.now().toString();
                        // 优先使用会话管理页预先输入的名称；否则回退为首条消息前缀
                        const presetNameRaw = (localStorage.getItem('deepseekNewConversationName') || '').trim();
                        const namePrefix = presetNameRaw || (messageText.slice(0, 20) || '新会话');
                        const newEntry = {
                            id: newId,
                            name: namePrefix,
                            messages: JSON.parse(localStorage.getItem('deepseekConversation') || '[]'),
                            summary: null,
                            groupId: currentConversationGroupId || null,
                            model: window.MODEL_NAME,
                            updatedAt: new Date().toISOString(),
                            lastSummarizedMessageCount: 0
                        };
                        saved.push(newEntry);
                        localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                        localStorage.setItem('deepseekConversationId', newId);
                        // 清理临时名称键，避免影响下一次新建
                        try { localStorage.removeItem('deepseekNewConversationName'); } catch (_) {}
                    }
                } catch (e) {
                    console.error('自动创建持久会话失败：', e);
                }
                renderMessages();
                // 节流写回持久会话
                scheduleUpsertSavedConversation();

                showStatus('发送中...', true);
                stopBtn.style.display = 'flex';

                // 重置本轮思考过程缓存
                window._currentAssistantReasoning = '';
                window._reasoningCollapsed = false; // 默认展开
                const aiMsgObj = { role: 'assistant', content: '', reasoning: '' };
                currentConversation.push(aiMsgObj);
                saveConversation();
                scheduleUpsertSavedConversation();
                renderMessages();

                // 记录日志：开始一个聊天请求事件（请求体稍后在 fetch 中补全）
                let _chatEvtId = null;
                try {
                    _chatEvtId = (window.Logger && window.Logger.start({
                        type: 'chat_request',
                        endpoint: window.DEEPSEEK_API_URL,
                        model: window.MODEL_NAME,
                        req: { headersMasked: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ***masked***' } }
                    })) || null;
                } catch (_) { /* 忽略日志异常 */ }

                await fetchDeepSeekResponseStream(apiKey, messageText, aiMsgObj, _chatEvtId);

                stopBtn.style.display = 'none';
                hideStatus();
                saveConversation();
                renderMessages();
                if (sendBtn) sendBtn.disabled = false;
            } catch (error) {
                console.error('发送消息失败:', error);
                showStatus('发送失败：' + (error && error.message ? error.message : '请重试'));
                setTimeout(hideStatus, 5000);
                stopBtn.style.display = 'none';
                if (sendBtn) sendBtn.disabled = false;
                // 记录错误
                try { window.Logger && window.Logger.error({ endpoint: window.DEEPSEEK_API_URL, model: window.MODEL_NAME }, error); } catch (_) {}
            }
        }

        /**
         * 停止生成
         * 功能：停止AI消息的流式生成，隐藏停止按钮并显示状态提示
         * 参数：无
         * 返回值：无
         */
        function stopGeneration() {
            console.log("生成已中止");
            showStatus('已中止生成');
            stopBtn.style.display = 'none';
        }

        /**
         * 流式获取AI响应
         * 功能：向API发送请求，接收流式响应数据，实时更新AI消息内容
         * 参数：apiKey - API密钥，userMessage - 用户消息（已包含在currentConversation中，此参数暂未使用），aiMsgObj - AI消息对象，用于更新内容
         * 返回值：Promise，无返回值
         */
        async function fetchDeepSeekResponseStream(apiKey, userMessage, aiMsgObj, chatEvtId) {
            // 使用 currentConversation 的可用消息作为请求体。sendMessage 已经把用户消息加入 currentConversation，
            // 因此不需要再次追加 userMessage，避免重复发送同一条用户消息导致模型重复响应或上下文膨胀。
            const messagesPayload = currentConversation.filter(msg => msg.role !== 'assistant' || msg.content);

            // 构造记忆注入：分组记忆（对所有消息有效）+ 会话摘要（仅同组有效）
            let systemContentParts = [];
            try {
                const convId = localStorage.getItem('deepseekConversationId');
                const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const entry = saved.find(c => c.id === convId) || null;
                // 分组记忆：读取当前分组的 memorySummary
                if (currentConversationGroupId) {
                    const groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                    const g = groups.find(x => x.id === currentConversationGroupId);
                    if (g && g.memorySummary) {
                        systemContentParts.push(`分组记忆:\n${g.memorySummary}`);
                    }
                }
                // 会话摘要：仅当 entry 的 groupId 与当前分组一致（包括两者都为 null）时注入
                if (entry && entry.summary) {
                    const a = entry.groupId || null;
                    const b = currentConversationGroupId || null;
                    if (a === b) {
                        systemContentParts.push(`会话摘要:\n${entry.summary}`);
                    }
                }
            } catch (e) {
                console.warn('记忆注入构造失败，已忽略：', e);
            }

            const messagesForRequest = systemContentParts.length > 0
                ? [{ role: 'system', content: systemContentParts.join('\n\n') }].concat(messagesPayload)
                : messagesPayload;

            const requestBody = {
                model: MODEL_NAME,
                messages: messagesForRequest,
                temperature: 0.7,
                max_tokens: 40000,
                stream: true
            };

            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            };

            // 在发起请求前，把最终请求体补充到日志
            try { window.Logger && chatEvtId && window.Logger.append(chatEvtId, { req: { body: requestBody } }); } catch (_) {}

            const response = await fetch(DEEPSEEK_API_URL, {
                method: 'POST',
                headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                let errText = '';
                try { errText = await response.text(); } catch (e) { errText = '<无法读取响应体>'; }
                console.error('API 请求失败，status=', response.status, 'body=', errText);
                // 失败也写入日志并结束
                try { window.Logger && chatEvtId && window.Logger.end(chatEvtId, { res: { status: response.status, final: errText }, error: { message: 'API请求失败' } }); } catch (_) {}
                throw new Error(`API请求失败: ${response.status} ${response.statusText} ${errText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            let finished = false;

            // 记录成功返回的状态码
            try { window.Logger && chatEvtId && window.Logger.append(chatEvtId, { res: { status: response.status } }); } catch (_) {}

            while (!finished) {
                const { value, done } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });

                const parts = buffer.split('\n\n');
                buffer = parts.pop();

                for (const part of parts) {
                    const line = part.trim();
                    if (!line) continue;
                    const lines = line.split('\n').map(l => l.trim()).filter(Boolean);
                    for (const l of lines) {
                        if (!l.startsWith('data:')) continue;
                        const data = l.slice(5).trim();
                        if (data === '[DONE]') {
                            finished = true;
                            break;
                        }
                        try {
                            const json = JSON.parse(data);
                            // 附加一条流式片段到日志（截断由 logger 控制）
                            try { window.Logger && chatEvtId && window.Logger.append(chatEvtId, { type: 'chat_stream', res: { streamChunks: [data] } }); } catch (_) {}
                            // 内容增量
                            const delta = json.choices && json.choices[0] && (json.choices[0].delta ? json.choices[0].delta.content : (json.choices[0].text || ''));
                            if (delta) {
                                aiMsgObj.content += delta;
                                updateLastAssistantMessage(aiMsgObj.content);
                            }
                            // 思考过程增量（兼容多种字段命名）
                            const rDelta =
                                (json.choices && json.choices[0] && json.choices[0].delta && (
                                    json.choices[0].delta.reasoning_content ||
                                    (json.choices[0].delta.reasoning && (json.choices[0].delta.reasoning.content || json.choices[0].delta.reasoning))
                                )) ||
                                (json.choices && json.choices[0] && json.choices[0].message && json.choices[0].message.reasoning_content) || '';
                            if (rDelta) {
                                const rStr = String(rDelta);
                                try { window._currentAssistantReasoning = (window._currentAssistantReasoning || '') + rStr; } catch (_) {}
                                try { aiMsgObj.reasoning = (aiMsgObj.reasoning || '') + rStr; } catch (_) {}
                                try { saveConversation(); } catch (_) {}
                                try { scheduleUpsertSavedConversation(); } catch (_) {}
                                // 触发界面刷新以（在存在时）显示思考过程
                                updateLastAssistantMessage(aiMsgObj.content);
                            }
                        } catch (err) {
                            console.debug('解析流片段失败（可能不是 JSON）：', err);
                        }
                    }
                    if (finished) break;
                }
            }
            // 流结束后进行一次最终的持久写回，避免丢失最后片段
            try { upsertSavedConversationNow(); } catch (e) { /* 忽略上报 */ }
            // 流结束后自动尝试生成会话摘要（具备去重判断）
            try { await autoSummarizeIfNeeded(); } catch (e) { console.error('自动会话摘要失败：', e); }

            // 结束日志事件
            try { window.Logger && chatEvtId && window.Logger.end(chatEvtId, { type: 'chat_done' }); } catch (_) {}
        }

        /**
         * 自动摘要（防抖/去重）
         * 功能：当会话新增消息后，在流结束时触发自动摘要；仅当消息条数较上次摘要更多或此前无摘要时执行
         * 参数：无
         * 返回值：Promise
         */
        async function autoSummarizeIfNeeded() {
            const conversationId = localStorage.getItem('deepseekConversationId');
            if (!conversationId) return;
            let saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
            const idx = saved.findIndex(c => c.id === conversationId);
            if (idx === -1) return;

            const entry = saved[idx];
            const msgCount = currentConversation.length;
            const lastCount = entry.lastSummarizedMessageCount || 0;
            if (entry.summary && msgCount <= lastCount) return;

            const apiKey = (window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey'));
            if (!apiKey) return;
            if (!window.PROMPTS || !window.PROMPTS.SESSION_SUMMARY) return;

            const systemPrompt = window.PROMPTS.SESSION_SUMMARY;
            const userContent = currentConversation.map(m => `${(m.role||'').toUpperCase()}: ${m.content||''}`).join('\n');

            const modelToUse = window.MODEL_NAME || 'minimax/minimax-m2:free';
            const url = (window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');
            // 日志：开始摘要请求
            let _sumEvtId = null;
            try {
                _sumEvtId = (window.Logger && window.Logger.start({
                    type: 'summary_request',
                    endpoint: url,
                    model: modelToUse,
                    req: { headersMasked: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ***masked***' }, body: { model: modelToUse, messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userContent } ], temperature: 0.2 } }
                })) || null;
            } catch (_) {}

            const resp = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: modelToUse,
                    messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userContent } ],
                    temperature: 0.2
                })
            });
            try { window.Logger && _sumEvtId && window.Logger.append(_sumEvtId, { res: { status: resp.status } }); } catch (_) {}
            if (!resp.ok) { try { window.Logger && _sumEvtId && window.Logger.end(_sumEvtId, { error: { message: '摘要请求失败' } }); } catch (_) {} return; }
            const data = await resp.json();
            const summaryText = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : null;
            try { window.Logger && _sumEvtId && window.Logger.end(_sumEvtId, { type: 'summary_done', res: { final: data } }); } catch (_) {}
            if (!summaryText) return;

            // 更新会话摘要与计数
            saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
            const idx2 = saved.findIndex(c => c.id === conversationId);
            if (idx2 !== -1) {
                saved[idx2].summary = summaryText;
                saved[idx2].lastSummarizedMessageCount = msgCount;
                saved[idx2].updatedAt = new Date().toISOString();
                localStorage.setItem('savedDeepseekConversations', JSON.stringify(saved));
                // 若存在分组，则同步刷新分组记忆
                if (saved[idx2].groupId) {
                    try { await updateGroupMemory(saved[idx2].groupId); } catch (_) {}
                }
            }
        }

        /**
         * 更新分组记忆（index 侧）
         * 功能：聚合指定分组内所有会话的摘要，生成分组级记忆并写回 conversationGroups
         * 参数：groupId - 分组ID
         * 返回值：Promise
         */
        async function updateGroupMemory(groupId) {
            try {
                const saved = JSON.parse(localStorage.getItem('savedDeepseekConversations') || '[]');
                const groupSummaries = saved.filter(c => c.groupId === groupId && c.summary).map(c => c.summary);
                if (groupSummaries.length === 0) return;

                const apiKey = (window.OPENROUTER_API_KEY || localStorage.getItem('deepseekApiKey'));
                if (!apiKey) return;
                if (!window.PROMPTS || !window.PROMPTS.GROUP_SUMMARY) return;

                const systemPrompt = window.PROMPTS.GROUP_SUMMARY;
                const modelToUse = window.MODEL_NAME || 'minimax/minimax-m2:free';
                const url = (window.DEEPSEEK_API_URL || 'https://openrouter.ai/api/v1/chat/completions');
                // 日志：开始分组记忆请求
                let _gmEvtId = null;
                try {
                    _gmEvtId = (window.Logger && window.Logger.start({
                        type: 'groupmem_request',
                        endpoint: url,
                        model: modelToUse,
                        req: { headersMasked: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ***masked***' }, body: { model: modelToUse, messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: groupSummaries.join('\n\n') } ], temperature: 0.2 } }
                    })) || null;
                } catch (_) {}

                const resp = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({
                        model: modelToUse,
                        messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: groupSummaries.join('\n\n') } ],
                        temperature: 0.2
                    })
                });
                try { window.Logger && _gmEvtId && window.Logger.append(_gmEvtId, { res: { status: resp.status } }); } catch (_) {}
                if (!resp.ok) { try { window.Logger && _gmEvtId && window.Logger.end(_gmEvtId, { error: { message: '分组记忆请求失败' } }); } catch (_) {} return; }
                const data = await resp.json();
                const memoryText = data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : null;
                try { window.Logger && _gmEvtId && window.Logger.end(_gmEvtId, { type: 'groupmem_done', res: { final: data } }); } catch (_) {}
                if (!memoryText) return;

                let groups = JSON.parse(localStorage.getItem('conversationGroups') || '[]');
                const gi = groups.findIndex(g => g.id === groupId);
                if (gi !== -1) {
                    groups[gi].memorySummary = memoryText;
                    groups[gi].updatedAt = new Date().toISOString();
                    localStorage.setItem('conversationGroups', JSON.stringify(groups));
                }
            } catch (e) {
                console.error('updateGroupMemory 失败：', e);
            }
        }

        /**
         * 更新最后一条助手消息
         * 功能：实时更新页面上最后一条AI消息的内容，重新渲染Markdown并更新操作按钮，同时保存会话到localStorage
         * 参数：content - 要更新的消息内容
         * 返回值：无
         */
        function updateLastAssistantMessage(content) {
            const nodes = messageContainer.querySelectorAll('.message.ai-message');
            const last = nodes && nodes.length ? nodes[nodes.length - 1] : null;
            if (!last) {
                renderMessages();
                return;
            }
            try {
                const rawHtml = marked.parse(content || '');
                last.innerHTML = DOMPurify.sanitize(rawHtml);
            } catch (e) {
                last.textContent = content;
            }

            const existingActions = last.querySelector('.message-actions');
            if (existingActions) existingActions.remove();

            // 若已存在思考过程容器，移除以避免重复追加
            const existingReasoning = last.querySelector('.reasoning-block');
            if (existingReasoning) existingReasoning.remove();

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'action-btn';
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                copyToClipboard(content);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'action-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // 计算当前会话中最后一个 assistant 消息的索引并删除，避免依赖外部闭包变量导致引用错误
                let lastAssistantIndex = -1;
                for (let i = currentConversation.length - 1; i >= 0; i--) {
                    if (currentConversation[i] && currentConversation[i].role === 'assistant') {
                        lastAssistantIndex = i;
                        break;
                    }
                }
                if (lastAssistantIndex !== -1) deleteMessage(lastAssistantIndex);
            });

            actionsDiv.appendChild(copyBtn);
            actionsDiv.appendChild(deleteBtn);
            last.appendChild(actionsDiv);
            // 将实时更新的 assistant 内容保存到 localStorage，防止在生成过程中页面刷新/跳转导致内容丢失
            try { saveConversation(); } catch (e) { console.error('保存会话失败：', e); }
            // 节流写回持久会话
            try { scheduleUpsertSavedConversation(); } catch (e) { /* 忽略上报 */ }

            // 渲染思考过程（仅当存在思考内容时显示，默认展开，置于正文前）
            try {
                const rText = (window._currentAssistantReasoning || '').trim();
                if (rText) {
                    const reasoningBlock = document.createElement('div');
                    reasoningBlock.className = 'reasoning-block';

                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'reasoning-toggle';
                    const collapsed = !!window._reasoningCollapsed;
                    toggleBtn.textContent = collapsed ? '展开思考过程' : '收起思考过程';

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'reasoning-content';
                    try {
                        const rHtml = marked.parse(rText);
                        contentDiv.innerHTML = DOMPurify.sanitize(rHtml);
                    } catch (_) {
                        contentDiv.textContent = rText;
                    }
                    contentDiv.style.display = collapsed ? 'none' : 'block';

                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const willShow = (contentDiv.style.display === 'none');
                        contentDiv.style.display = willShow ? 'block' : 'none';
                        window._reasoningCollapsed = !willShow;
                        toggleBtn.textContent = willShow ? '收起思考过程' : '展开思考过程';
                    });

                    reasoningBlock.appendChild(toggleBtn);
                    reasoningBlock.appendChild(contentDiv);
                    // 插入到消息内容最前面（位于正文之前）
                    last.insertBefore(reasoningBlock, last.firstChild);
                }
            } catch (_) { /* 忽略思考过程渲染异常 */ }
            scrollToBottom();
        }

        /**
         * 复制到剪贴板
         * 功能：将指定文本复制到系统剪贴板，并显示状态提示
         * 参数：text - 要复制的文本内容
         * 返回值：无
         */
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showStatus('已复制到剪贴板');
                setTimeout(hideStatus, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
                showStatus('复制失败');
                setTimeout(hideStatus, 2000);
            });
        }

        /**
         * 删除消息
         * 功能：从当前会话中删除指定索引的消息，并保存会话
         * 参数：index - 要删除的消息索引
         * 返回值：无
         */
        function deleteMessage(index) {
            currentConversation.splice(index, 1);
            saveConversation(); // 确保在删除后保存对话
            renderMessages();
        }

        /**
         * 显示状态提示
         * 功能：在状态指示器中显示文本提示，可选择是否显示加载动画
         * 参数：text - 要显示的文本，isLoading - 是否显示加载动画，默认为false
         * 返回值：无
         */
        function showStatus(text, isLoading = false) {
            statusIndicator.textContent = '';

            if (isLoading) {
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'loading-animation';

                const dot1 = document.createElement('div');
                dot1.className = 'loading-dot';
                const dot2 = document.createElement('div');
                dot2.className = 'loading-dot';
                const dot3 = document.createElement('div');
                dot3.className = 'loading-dot';

                loadingDiv.appendChild(dot1);
                loadingDiv.appendChild(dot2);
                loadingDiv.appendChild(dot3);

                const textNode = document.createTextNode(text);
                statusIndicator.appendChild(loadingDiv);
                statusIndicator.appendChild(textNode);
            } else {
                statusIndicator.textContent = text;
            }
        }

        /**
         * 隐藏状态提示
         * 功能：清空状态指示器的内容
         * 参数：无
         * 返回值：无
         */
        function hideStatus() {
            statusIndicator.textContent = '';
        }

        /**
         * 滚动到底部
         * 功能：将消息容器滚动到最底部，显示最新消息
         * 参数：无
         * 返回值：无
         */
        function scrollToBottom() {
            messageContainer.scrollTop = messageContainer.scrollHeight;
        }
    </script>
</body>
</html>